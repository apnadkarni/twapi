#
# Copyright (c) 2004-2012, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license

# This file contains tests for commands from the eventlog.tcl

package require tcltest
eval tcltest::configure $argv

source [file join [file dirname [info script]] testutil.tcl]
load_twapi_package twapi_etw
load_twapi_package twapi_process; # Needed for proc privileged

source csv.tcl

namespace eval twapi::etw::test {
    namespace import ::tcltest::test

    variable logdir [tcltest::makeDirectory etwlogs]
    proc new_etl_filepath {} {
        variable logdir
        return [file join $logdir [new_name].etl]
    }

    proc privileged {} {
        if {[twapi::min_os_version 6]} {
            if {[twapi::process_in_administrators] &&
                [twapi::get_process_elevation] eq "full"} {
                return 1
            } else {
                return 0
            }
        } else {
            return [twapi::process_in_administrators]
        }
    }
    ::tcltest::testConstraint privileged [privileged]

    proc tracerpt_file {file} {
        variable logdir
        set csvfile [file join $logdir tracerpt_[clock clicks].csv]
        if {[twapi::min_os_version 6]} {
            exec tracerpt $file -o $csvfile -of csv
        } else {
            exec tracerpt $file -o $csvfile
        }
        set lines [lassign [split [read_file $csvfile] \n] header]
        set keys {}
        foreach field [csv::split $header] {
            lappend keys [string trim $field]
        }
        set nkeys [llength $keys]
        set recs {}
        foreach line $lines {
            set line [string trim $line]
            if {$line eq ""} {
                continue
            }
            set rec {}
            foreach field [csv::split $line] {
                lappend rec [string trim $field]
            }
            if {[llength $rec] > $nkeys} {
                # Append remaining fields to last record
                lappend recs [list {*}[lrange $rec 0 $nkeys-2] [lrange $rec $nkeys-1 end]]
            } else {
                lappend recs $rec
            }
        }
        return [list $keys $recs]
    }

    proc validate_buf {buf logger} {
        # Buffer header 
        lassign $buf {*}[twapi::etw_event_trace_logfile]

        if {$logfile eq "" && $logger_name eq ""} {
            error "Log file and logger name are both empty"
        }
        if {$logfile ne "" && ![same_file $logfile $logger]} {
            error "Log file name $logfile does not match $logger."
        }

        if {$logger_name ne "" && [string compare -nocase $logger_name $logger]} {
            error "Logger name $logger_name does not match $logger."
        }

        if {$current_time < [twapi::timelist_to_large_system_time {2014 01 01 0 0 0}] ||
            $current_time > [twapi::get_system_time]} {
            error "Current time $current_time out of range"
        }

        if {$buffers_read < 0 ||
            $buffer_size < 0 ||
            $filled <= 0 ||
            ![string is boolean -strict $kernel_trace]} {
            error "Invalid buffer usage counts"
        }
        
        set hdr [twapi::etw_trace_logfile_header $trace_logfile_header]
        # Verify integer keys
        foreach key {buffer_size version_major version_minor
            version_submajor version_subminor
            provider_version processor_count end_time timer_resolution
            max_file_size logfile_mode buffers_written events_lost
            cpu_mhz boot_time perf_frequency start_time reserved_flags
            buffers_lost
        } {
            dict incr hdr $key; # Will error if not integer
        }

        if {[dict get $hdr pointer_size] != 4 &&
            [dict get $hdr pointer_size] != 8} {
            error "Pointer size is not 4 or 8."
        }

        return
    }

    # events is a recordarray
    proc validate_events {events etlfile} {
        lassign [tracerpt_file $etlfile] tracerpt_keys tracerpt_events
        if {[twapi::recordarray size $events] != [llength $tracerpt_events]} {
            error "Number of events reported by tracerpt ([llength $tracerpt_events]) different from [twapi::recordarray size $events]"
        }
        foreach ev [twapi::recordarray getlist $events -format dict] tracerpt_event $tracerpt_events {
            array set tev [twapi::twine $tracerpt_keys $tracerpt_event]
            # Note fields in tev depend on Windows version
            foreach {fld tfld} {
                {-taskname {Event Name}}
                {-opcodename Type}
                {-eventid {Event ID}}
                {-version Version}
                {-channel Channel}
                {-level Level}
                {-opcode Opcode}
                {-task Task}
                {-keywordmask Keyword}
                {-pid PID}
                {-tid TID}
                {-timecreated Clock-Time}
            } {
                if {[info exists tev($tfld)] &&
                    $tev($tfld) != [dict get $ev $fld]} {
                    error "Event field $fld value ([dict get $ev $fld]) does not match tracerpt value $tev($tfld)"
                }
            }
            foreach {fld tfld} {
                {-kerneltime Kernel(ms)}
                {-usertime User(ms)}
            } {
                if {[info exists tev($tfld)] &&
                    ($tev($tfld) != [dict get $ev $fld]/10000)} {
                    error "Event field $fld value ([dict get $ev $fld]) does not match tracerpt value $tev($tfld)/10000"
                }
            }

            # Unfortunately, cannot check user data as tracerpt will happily skip complex fields like timezone
            if {0 && [info exists "tev(User Data)"]} {
                foreach tdata $tev(User Data) {fld val} [dict get $ev -properties] {
                    if {$tdata != $val} {
                        error "User data $fld=$val does not match tracerpt value $tdata"
                    }
                }
            }
        }
    }

    proc validate_trace_stats {stats path name} {
        set diff [setops::diff {
            logfile trace_name trace_guid buffer_size min_buffers max_buffers
            max_file_size logfile_mode flush_timer enable_flags clock_resolution
            age_limit buffer_count free_buffers events_lost buffers_written
            log_buffers_lost real_time_buffers_lost logger_tid
        } [dict keys $stats]]

        if {[llength $diff]} {
            error "Keys [join $diff ,] missing from trace stats dictionary"
        }

        # TBD - clock_resolution ?
        foreach key {
            buffer_size min_buffers max_buffers
            max_file_size logfile_mode flush_timer enable_flags
            age_limit buffer_count free_buffers events_lost buffers_written
            log_buffers_lost real_time_buffers_lost logger_tid
        } {
            if {![string is wide [dict get $stats $key]]} {
                error "Value for $key in trace stats dictionary is not an integer"
            }
        }

        if {![equal_paths $path [dict get $stats logfile]]} {
            error "Log file paths do not match: $path != [dict get $stats logfile]"
        }

        if {! [string equal -nocase $name [dict get $stats trace_name]]} {
            error "Trace names do not match"
        }
        
        return
    }

    test etw_install_mof-1.0 {
        TBD - etw_install_mof
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_uninstall_mof-1.0 {
        TBD - etw_uninstall_mof
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_twapi_provider_register-1.0 {
        TBD - etw_register_provider
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_log_message-1.0 {
        TBD - etw_log_message
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_variable_tracker-1.0 {
        TBD - etw_variable_tracker
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_execution_tracker-1.0 {
        TBD - etw_execution_tracker
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_command_tracker-1.0 {
        TBD - etw_command_tracker
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_parse_mof_event_class-1.0 {
        TBD - etw_parse_mof_event_class
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_find_mof_event_classes-1.0 {
        TBD - etw_find_mof_event_classes
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_get_all_mof_event_classes-1.0 {
        TBD - etw_get_all_mof_event_classes
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_load_mof_event_class_obj-1.0 {
        TBD - etw_load_mof_event_class_obj
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_load_mof_event_classes-1.0 {
        TBD - etw_load_mof_event_classes
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_open_file-1.0 {
        etw_open_file
    } -body {
        set etw [twapi::etw_open_file kernel.etl]
    } -cleanup {
        twapi::etw_close_session $etw
    } -result {\d+} -match regexp

    test etw_open_file-2.0 {
        etw_open_file non-existing file
    } -body {
        list [catch {twapi::etw_open_file nosuchfile.etl}] [lindex $::errorCode 0] [expr {[lindex $::errorCode 1] in {2 161}}]
    } -result {1 TWAPI_WIN32 1}

    test etw_open_file-100.0 {
        TBD - etw_open_file        
    } -constraints {
        TBD
    } -body {
        # 32 bit file on 64 bits
        # 64 bit file on 32 bits
        # mof based providers
        # manifest based providers
    } -result TBD

    test etw_open_session-1.0 {
        TBD - etw_open_session
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_close_session-1.0 {
        etw_close_session (file)
    } -body {
        twapi::etw_close_session [twapi::etw_open_file kernel.etl]
    } -result ""

    test etw_close_session-2.0 {
        etw_close_session (real time)
    } -constraints {
        privileged TBD
    } -body {
    } -result TBD

    test etw_close_session-3.0 {
        etw_close_session (previously closed)
    } -setup {
        set etw [twapi::etw_open_file kernel.etl]
        twapi::etw_close_session $etw
    } -body {
        twapi::etw_close_session $etw
    } -result "Cannot find trace session*" -returnCodes error -match glob

    test etw_consumer-1.0 {
        Test etw_process_events/etw_format_events
    } -setup {
        set etw [twapi::etw_open_file kernel.etl]
        set formatter [twapi::etw_open_formatter]
    } -body {
        set l [twapi::etw_process_events $etw]
        set ras {}
        foreach {buf events} $l {
            validate_buf $buf kernel.etl
            lappend ras [twapi::etw_format_events $formatter $buf $events]
        }
        validate_events [twapi::recordarray concat {*}$ras] kernel.etl
    } -cleanup {
        twapi::etw_close_formatter $formatter
        twapi::etw_close_session $etw
    } -result ""


    proc process_events_cb {formatter logfile varname bufd events} {
        validate_buf $bufd $logfile
        lappend $varname [twapi::etw_format_events $formatter $bufd $events]
    }

    test etw_consumer-2.0 {
        Test etw_process_events/etw_format_events - callback
    } -setup {
        set etw [twapi::etw_open_file kernel.etl]
        set formatter [twapi::etw_open_formatter]
    } -body {
        set varname ::etw_consumer_[clock microseconds]
        set l [twapi::etw_process_events -callback [list [namespace current]::process_events_cb $formatter kernel.etl $varname] $etw]
        validate_events [twapi::recordarray concat {*}[set $varname]] kernel.etl
        set l
    } -cleanup {
        twapi::etw_close_formatter $formatter
        twapi::etw_close_session $etw
    } -result ""


    test etw_consumer-100.0 {
        TBD - etw_process_events
    } -constraints {
        TBD
    } -body {
        # 32 bit file on 64 bits
        # 64 bit file on 32 bits
        # mof based providers
        # manifest based providers
        # Callback mode
        # MUltiple trace files
        # -starttime, -endtime
    } -result TBD

    test etw_format_events-1.0 {
        TBD - etw_format_events
    } -constraints {
        TBD
    } -body {
        # 32 bit file on 64 bits
        # 64 bit file on 32 bits
        # mof based providers
        # manifest based providers
        # -match option
    } -result TBD

    test etw_dump_files-1.0 {
        TBD - etw_dump_files
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_start_trace-1.0 {
        TBD - etw_start_trace
    } -constraints {
        TBD
    } -body {
        etw_start_trace "NT Kernel Logger" -logfile k.etl -filemodecircular -maximumfilesize 1
    } -result TBD

    test etw_start_kernel_trace-1.0 {
        Start kernel trace (basic)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        twapi::etw_start_kernel_trace {} -logfile $etl
        twapi::etw_stop_trace "NT Kernel Logger"
        file exists $etl
    } -result 1

    # NOTE
    # For -filemode tests, there is no easy way to confirm the actual
    # mode implemented be looking at the log file. There are too many
    # differences between Windows versions and actually reading the log
    # to check for event overwrites etc. does not help because different
    # Windows versions will log "state dump" events on closure which
    # makes it difficult to check for circular mode etc.
    #
    # So instead, we just check what mode Windows returns by querying
    # the trace and assume verifying that is sufficient.

    test etw_start_kernel_trace-2.0 {
        Start kernel trace (verify -filemode default is circular)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl]
        set status [twapi::etw_query_trace $htrace]
        # Next command will fail if file mode was not circular as
        # log would get full and the trace would have already stopped
        twapi::etw_stop_trace $htrace
        list [expr {([dict get $status logfile_mode] & 15)}] [dict get $status max_file_size] [dict get $status clock_resolution]
    } -result {2 1 system}

    test etw_start_kernel_trace-2.1 {
        Start kernel trace (verify -filemode circular, -clockresolution qpc)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl -filemode circular -clockresolution qpc]
        set status [twapi::etw_query_trace $htrace]
        # Next command will fail if file mode was not circular as
        # log would get full and the trace would have already stopped
        twapi::etw_stop_trace $htrace
        expr {([dict get $status logfile_mode] & 15)}
        list [expr {([dict get $status logfile_mode] & 15)}] [dict get $status max_file_size] [dict get $status clock_resolution]
    } -result {2 1 qpc}

    test etw_start_kernel_trace-2.2 {
        Start kernel trace (verify -filemode sequential, no max file size)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl -filemode sequential -clockresolution cpucycle]
        set status [twapi::etw_query_trace $htrace]
        twapi::etw_stop_trace $htrace
        list [expr {([dict get $status logfile_mode] & 15)}] [dict get $status max_file_size] [dict get $status clock_resolution]
    } -result {0 0 cpucycle}


    test etw_start_kernel_trace-2.3 {
        Start kernel trace (verify -filemode sequential -maxfilesize)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl -filemode sequential -maxfilesize 10]
        set status [twapi::etw_query_trace $htrace]
        twapi::etw_stop_trace $htrace
        list [expr {([dict get $status logfile_mode] & 15)}] [dict get $status max_file_size]
    } -result {1 10}

    test etw_start_kernel_trace-2.4 {
        Start kernel trace (verify -filemode rotate)
    } -constraints {
        privileged TBD
    } -body {
        set etl [file join $logdir [new_name]-%d.etl]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl -filemode rotate]
    } -result "Option -filemode cannot have value \"rotate\" for NT Kernel Logger" -returnCodes error


    test etw_start_kernel_trace-2.5 {
        Start kernel trace (verify -filemode append)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl -filemode append]
        after 500
        set status [twapi::etw_query_trace $htrace]
        # Next command will fail if file mode was not circular as
        # log would get full and the trace would have already stopped
        twapi::etw_stop_trace $htrace
        list [expr {([dict get $status logfile_mode] & 15) in {4 5}}] [dict get $status max_file_size]
    } -result {1 0}

    test etw_provider-1.0 {
        Tests etw_start_trace/etw_stop_trace/etw_update_trace/etw_log_message/etw_enable_trace/etw_disable_trace
    } -constraints {
        privileged
    } -setup {
        twapi::etw_install_twapi_mof
    } -body {
        set etl [new_etl_filepath]
        set tracename "TWAPITEST_[clock microseconds]"
        set hprov [twapi::etw_twapi_provider_register]
        set htrace [twapi::etw_start_trace $tracename -logfile $etl]
        twapi::etw_enable_provider $htrace [twapi::etw_twapi_provider_guid] -1 5
        set wait_time 200;      # Need to wait for level changes to effect
        after $wait_time;              # Needs a bit of time to take effect
        set curtid [twapi::get_current_thread_id]
        for {set level 5} {$level > 0} {incr level -1} {
            set tid [twapi::get_current_thread_id]
            if {$tid != $curtid} {
                puts "TID changed"
                set curtid $tid
            }

            twapi::etw_log_message $hprov "SETLEVEL_$level" 1
            twapi::etw_enable_provider $htrace [twapi::etw_twapi_provider_guid] -1 $level
            after $wait_time
            twapi::etw_log_message $hprov "default"
            twapi::etw_log_message $hprov "1" 1
            twapi::etw_log_message $hprov "2" 2
            twapi::etw_log_message $hprov "3" 3
            twapi::etw_log_message $hprov "4" 4
            twapi::etw_log_message $hprov "5" 5

            twapi::etw_flush_trace  $htrace
        }

        # Repeat using tokens for levels
        set curtid [twapi::get_current_thread_id]
        foreach level {verbose informational warning error fatal} {
            set tid [twapi::get_current_thread_id]
            if {$tid != $curtid} {
                puts "TID changed"
                set curtid $tid
            }
            twapi::etw_log_message $hprov "SETLEVEL_$level" 1
            # Use name instead of guid
            twapi::etw_enable_provider $htrace [twapi::etw_twapi_provider_name] -1 $level
            after $wait_time
            twapi::etw_log_message $hprov "default"
            twapi::etw_log_message $hprov "fatal" fatal
            twapi::etw_log_message $hprov "error" error
            twapi::etw_log_message $hprov "warning" warning
            twapi::etw_log_message $hprov "informational" informational
            twapi::etw_log_message $hprov "verbose" verbose
            
            twapi::etw_flush_trace  $tracename
        }

        # Now disable the provider and try to log - use name instead of guid
        twapi::etw_disable_provider $htrace [twapi::etw_twapi_provider_name]
        after $wait_time
        twapi::etw_log_message $hprov "fatal (provider disabled)" 1
        twapi::etw_flush_trace  $htrace
        twapi::etw_stop_trace  $htrace
        # Now see if messages were logged as expected
        set errors {}
        set htrace [twapi::etw_open_file $etl]
        set formatter [twapi::etw_open_formatter]
        set events [twapi::etw_format_events $formatter {*}[twapi::etw_process_events $htrace]]
        twapi::etw_close_formatter $formatter
        set result {}
        foreach event [twapi::recordarray getlist $events -format dict] {
            if {[dict get $event -providername] in {TwapiETWEventClass TwapiETWProvider}} {
                lappend result [dict get $event -properties Message]
            }
        }
        set result
    } -result {SETLEVEL_5 default 1 2 3 4 5 SETLEVEL_4 default 1 2 3 4 SETLEVEL_3 1 2 3 SETLEVEL_2 1 2 SETLEVEL_1 1 SETLEVEL_verbose default fatal error warning informational verbose SETLEVEL_informational default fatal error warning informational SETLEVEL_warning fatal error warning SETLEVEL_error fatal error SETLEVEL_fatal fatal}


    ################################################################

    test etw_update_trace-1.0 {
        etw_update_trace using trace handle -flushtimer
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set name TWAPITRACE-[clock microseconds]
        set htrace [twapi::etw_start_trace $name -logfile $etl]
    } -body {
        set stats [twapi::etw_query_trace $htrace]
        validate_trace_stats $stats $etl $name
        set flush_timer [dict get $stats flush_timer]
        incr flush_timer 10
        set stats2 [twapi::etw_update_trace $htrace -flushtimer $flush_timer]
        validate_trace_stats $stats2 $etl $name
        list \
            [tcl::mathop::== [dict get $stats2 flush_timer] $flush_timer] \
            [tcl::mathop::== [dict get $stats2 max_buffers] [dict get $stats max_buffers]] \
            [equal_paths [dict get $stats2 logfile] [dict get $stats logfile]] \
            [tcl::mathop::== [dict get $stats2 enable_flags] [dict get $stats enable_flags]] \
            [tcl::mathop::& [dict get $stats2 logfile_mode] 0x100]
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result {1 1 1 1 0}

    test etw_update_trace-2.0 {
        etw_update_trace using trace handle -logfile
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set name TWAPITRACE-[clock microseconds]
        set htrace [twapi::etw_start_trace $name -logfile $etl]
    } -body {
        set stats [twapi::etw_query_trace $htrace]
        validate_trace_stats $stats $etl $name
        set etl2 [new_etl_filepath]
        set stats2 [twapi::etw_update_trace $name -logfile $etl2]
        validate_trace_stats $stats2 $etl2 $name
        list \
            [tcl::mathop::== [dict get $stats2 flush_timer] [dict get $stats flush_timer]] \
            [tcl::mathop::== [dict get $stats2 max_buffers] [dict get $stats max_buffers]] \
            [equal_paths [dict get $stats2 logfile] $etl2] \
            [tcl::mathop::== [dict get $stats2 enable_flags] [dict get $stats enable_flags]] \
            [tcl::mathop::& [dict get $stats2 logfile_mode] 0x100]
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result {1 1 1 1 0}

    test etw_update_trace-3.0 {
        etw_update_trace using trace handle -maxbuffers
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set name TWAPITRACE-[clock microseconds]
        set htrace [twapi::etw_start_trace $name -logfile $etl]
    } -body {
        set stats [twapi::etw_query_trace $htrace]
        validate_trace_stats $stats $etl $name
        set max_buffers [dict get $stats max_buffers]
        incr max_buffers 1
        set stats2 [twapi::etw_update_trace $htrace -maxbuffers $max_buffers]
        validate_trace_stats $stats2 $etl $name
        list \
            [tcl::mathop::== [dict get $stats2 max_buffers] $max_buffers] \
            [tcl::mathop::== [dict get $stats2 flush_timer] [dict get $stats flush_timer]] \
            [equal_paths [dict get $stats2 logfile] [dict get $stats logfile]] \
            [tcl::mathop::== [dict get $stats2 enable_flags] [dict get $stats enable_flags]] \
            [tcl::mathop::& [dict get $stats2 logfile_mode] 0x100]
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result {1 1 1 1 0}

    test etw_update_trace-4.0 {
        etw_update_trace using trace name -enableflags
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set name "NT Kernel Logger"; # Required for -enableflags
        set htrace [twapi::etw_start_kernel_trace {registry process thread} -logfile $etl]
    } -body {
        set stats [twapi::etw_query_trace $htrace]
        validate_trace_stats $stats $etl $name
        set enable_flags [dict get $stats enable_flags]
        if {($enable_flags & 0x0fffffff) != 0x00020003} {
            error "enable_flags=[format 0x%x $enable_flags], expected 0x00020003"
        }
        set enable_flags [expr {$enable_flags & ~0x1}]
        set stats2 [twapi::etw_update_trace $name -enableflags $enable_flags]
        validate_trace_stats $stats2 $etl $name
        list \
            [tcl::mathop::== [dict get $stats2 max_buffers] [dict get $stats max_buffers]] \
            [tcl::mathop::== [dict get $stats2 flush_timer] [dict get $stats flush_timer]] \
            [equal_paths [dict get $stats2 logfile] [dict get $stats logfile]] \
            [expr {([dict get $stats2 enable_flags] & 0x7fffffff) == $enable_flags}] \
            [tcl::mathop::& [dict get $stats2 logfile_mode] 0x100]
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result {1 1 1 1 0}


    test etw_update_trace-5.0 {
        etw_update_trace using trace handle -realtime 0
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set name TWAPITRACE-[clock microseconds]
        set htrace [twapi::etw_start_trace $name -logfile $etl -realtime 1]
    } -body {
        set stats [twapi::etw_query_trace $htrace]
        validate_trace_stats $stats $etl $name
        set logfile_mode [dict get $stats logfile_mode]
        if {($logfile_mode & 0x100) == 0} {
            error "Log file mode does not have real time bit set"
        }
        set stats2 [twapi::etw_update_trace $htrace -realtime 0]
        validate_trace_stats $stats2 $etl $name
        list \
            [tcl::mathop::== [dict get $stats2 max_buffers] [dict get $stats max_buffers]] \
            [tcl::mathop::== [dict get $stats2 flush_timer] [dict get $stats flush_timer]] \
            [equal_paths [dict get $stats2 logfile] [dict get $stats logfile]] \
            [tcl::mathop::== [dict get $stats2 enable_flags] [dict get $stats enable_flags]] \
            [tcl::mathop::& [dict get $stats2 logfile_mode] 0x100]
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result {1 1 1 1 0}


    test etw_update_trace-5.1 {
        etw_update_trace using trace handle -realtime 1
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set name TWAPITRACE-[clock microseconds]
        set htrace [twapi::etw_start_trace $name -logfile $etl -realtime 0]
    } -body {
        set stats [twapi::etw_query_trace $htrace]
        validate_trace_stats $stats $etl $name
        set logfile_mode [dict get $stats logfile_mode]
        if {$logfile_mode & 0x100} {
            error "Log file mode has real time bit set"
        }
        set stats2 [twapi::etw_update_trace $htrace -realtime 1]
        validate_trace_stats $stats2 $etl $name
        # Note we do not check flush timer because behaviour differs
        # between XP and later versions
        list \
            [tcl::mathop::== [dict get $stats2 max_buffers] [dict get $stats max_buffers]] \
            [equal_paths [dict get $stats2 logfile] [dict get $stats logfile]] \
            [tcl::mathop::== [dict get $stats2 enable_flags] [dict get $stats enable_flags]] \
            [tcl::mathop::& [dict get $stats2 logfile_mode] 0x100]
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result {1 1 1 256}


    ################################################################

    test etw_get_traces-1.0 {
        etw_get_traces
    } -body {
        foreach name [twapi::etw_get_traces] {
            set stats [twapi::etw_query_trace $name]
            validate_trace_stats $stats [dict get $stats logfile] $name
        }
    } -result ""

    test etw_get_traces-2.0 {
        etw_get_traces -detail
    } -body {
        foreach stats [twapi::etw_get_traces -detail] {
            validate_trace_stats $stats [dict get $stats logfile] [dict get $stats trace_name]
        }
    } -result ""

    ################################################################

    test etw_get_provider_guid-1.0 {
        etw_get_provider_guid
    } -body {
        string tolower [twapi::etw_get_provider_guid "Windows Kernel Trace"]
    } -result {{9e814aad-3204-11d2-9a82-006008a86939}}

    test etw_get_provider_guid-1.1 {
        etw_get_provider_guid - case insensitive
    } -body {
        string tolower [twapi::etw_get_provider_guid "windows kernel trace"]
    } -result {{9e814aad-3204-11d2-9a82-006008a86939}}

    test etw_get_provider_guid-2.0 {
        etw_get_provider_guid - non-existing
    } -body {
        twapi::etw_get_provider_guid " windows kernel trace"
    } -result ""

    ################################################################

    test etw_get_providers-1.0 {
        etw_get_providers
    } -setup {
        foreach rec [split [exec {*}[auto_execok logman] query providers] \n] {
            if {[regexp {(^.*)({.*})$} [string trim $rec] -> name guid]} {
                set name [regsub {\s+} [string trim $name] { }]
                # Lappend because logman reports both old style and
                # new style for the same guid
                dict lappend logman_providers $name $guid
            }
        }
    } -body {
        set providers [twapi::etw_get_providers]
        foreach name $providers {
            if {![dict exists $logman_providers $name]} {
                error "$name not found in logman output"
            }
        }
    } -result ""

    test etw_get_providers-1.1 {
        etw_get_providers -detail
    } -setup {
        foreach rec [split [exec {*}[auto_execok logman] query providers] \n] {
            if {[regexp {(^.*)({.*})$} [string trim $rec] -> name guid]} {
                set name [regsub {\s+} [string trim $name] { }]
                # Lappend because logman reports both old style and
                # new style for the same guid
                dict lappend logman_providers $guid $name
            }
        }
    } -body {
        set providers [twapi::etw_get_providers -detail]
        foreach rec $providers {
            dict with rec {}
            if {$type ni {mof xml}} {
                error "Unknown type $type"
            }
            if {![dict exists $logman_providers $guid]} {
                error "$guid not found in logman output"
            }
            if {$name ni [dict get $logman_providers $guid]} {
                error "Name $name does not match logman output [dict get $logman_providers $guid]"
            }
        }
    } -result ""

    ################################################################

    test etw_query_trace-1.0 {
        etw_query_trace using trace handle
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl]
    } -body {
        set stats [twapi::etw_query_trace $htrace]
        catch {validate_trace_stats $stats $etl "NT Kernel Logger"}
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result 0

    test etw_query_trace-2.0 {
        etw_query_trace using trace name
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set name TWAPITRACE-[clock microseconds]
        set htrace [twapi::etw_start_trace $name -logfile $etl]
    } -body {
        set stats [twapi::etw_query_trace $name]
        catch {validate_trace_stats $stats $etl $name}
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result 0

    test etw_stop_trace-1.0 {
        etw_stop_trace using trace handle
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl]
    } -body {
        set stats [twapi::etw_stop_trace $htrace]
        validate_trace_stats $stats $etl "NT Kernel Logger"
        list [catch {twapi::etw_stop_trace $htrace}] [errorcode]
    } -result {1 {TWAPI_WIN32 4201}}

    test etw_stop_trace-2.0 {
        etw_stop_trace using trace name
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set name TWAPITRACE-[clock microseconds]
        set htrace [twapi::etw_start_trace $name -logfile $etl]
    } -body {
        set stats [twapi::etw_stop_trace $name]
        validate_trace_stats $stats $etl $name
        list [catch {twapi::etw_stop_trace $htrace}] [errorcode]
    } -result {1 {TWAPI_WIN32 4201}}

    test etw_flush_trace-1.0 {
        etw_flush_trace using trace handle
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl]
    } -body {
        set stats [twapi::etw_flush_trace $htrace]
        catch {validate_trace_stats $stats $etl "NT Kernel Logger"}
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result 0

    test etw_flush_trace-2.0 {
        etw_flush_trace using trace name
    } -constraints {
        privileged
    } -setup {
        set etl [new_etl_filepath]
        set htrace [twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl]
    } -body {
        set stats [twapi::etw_flush_trace "NT Kernel Logger"]
        catch {validate_trace_stats $stats $etl "NT Kernel Logger"}
    } -cleanup {
        twapi::etw_stop_trace $htrace
    } -result 0

}

#
# Clean up
catch {twapi::etw_uninstall_twapi_mof}
::tcltest::cleanupTests
namespace delete ::twapi::etw::test
