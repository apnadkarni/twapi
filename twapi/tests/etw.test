#
# Copyright (c) 2004-2012, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license

# This file contains tests for commands from the eventlog.tcl

package require tcltest
eval tcltest::configure $argv

source [file join [file dirname [info script]] testutil.tcl]
load_twapi_package twapi_etw
load_twapi_package twapi_process; # Needed for proc privileged

catch {package require csv}

namespace eval twapi::etw::test {
    namespace import ::tcltest::test

    variable logdir [tcltest::makeDirectory etwlogs]
    proc new_etl_filepath {{prefix twapitest}} {
        variable logdir
        return [file join $logdir ${prefix}-[clock microseconds].etl]
    }

    proc privileged {} {
        if {[twapi::min_os_version 6]} {
            if {[twapi::process_in_administrators] &&
                [twapi::get_process_elevation] eq "full"} {
                return 1
            } else {
                return 0
            }
        } else {
            return [twapi::process_in_administrators]
        }
    }
    ::tcltest::testConstraint privileged [privileged]

    proc tracerpt_file {file} {
        variable logdir
        set csvfile [file join $logdir tracerpt_[clock clicks].csv]
        exec tracerpt $file -o $csvfile -of csv
        set lines [lassign [split [read_file $csvfile] \n] header]
        set keys {}
        foreach field [csv::split $header] {
            lappend keys [string trim $field]
        }
        set nkeys [llength $keys]
        set recs {}
        foreach line $lines {
            set line [string trim $line]
            if {$line eq ""} {
                continue
            }
            set rec {}
            foreach field [csv::split $line] {
                lappend rec [string trim $field]
            }
            if {[llength $rec] > $nkeys} {
                # Append remaining fields to last record
                lappend recs [list {*}[lrange $rec 0 $nkeys-2] [lrange $rec $nkeys-1 end]]
            } else {
                lappend recs $rec
            }
        }
        return [list $keys $recs]
    }

    proc validate_buf {buf logger} {
        # Buffer header 
        lassign $buf {*}[twapi::etw_event_trace_logfile]

        if {$logfile eq "" && $logger_name eq ""} {
            error "Log file and logger name are both empty"
        }
        if {$logfile ne "" && ![same_file $logfile $logger]} {
            error "Log file name $logfile does not match $logger."
        }

        if {$logger_name ne "" && [string compare -nocase $logger_name $logger]} {
            error "Logger name $logger_name does not match $logger."
        }

        if {$current_time < [twapi::timelist_to_large_system_time {2014 01 01 0 0 0}] ||
            $current_time > [twapi::get_system_time]} {
            error "Current time $current_time out of range"
        }

        if {$buffers_read <= 0 ||
            $buffer_size < 0 ||
            $filled <= 0 ||
            ![string is boolean -strict $kernel_trace]} {
            error "Invalid buffer usage counts"
        }
        
        set hdr [twapi::etw_trace_logfile_header $trace_logfile_header]
        # Verify integer keys
        foreach key {buffer_size version_major version_minor
            version_submajor version_subminor
            provider_version processor_count end_time timer_resolution
            max_file_size logfile_mode buffers_written events_lost
            cpu_mhz boot_time perf_frequency start_time reserved_flags
            buffers_lost
        } {
            dict incr hdr $key; # Will error if not integer
        }

        if {[dict get $hdr pointer_size] != 4 &&
            [dict get $hdr pointer_size] != 8} {
            error "Pointer size is not 4 or 8."
        }

        return
    }


    proc validate_events {events etlfile} {
        lassign [tracerpt_file $etlfile] tracerpt_keys tracerpt_events
        if {[llength $events] != [llength $tracerpt_events]} {
            error "Number of events reported by tracerpt ([llength $tracerpt_events]) different from [llength $events]"
        }
        foreach ev $events tracerpt_event $tracerpt_events {
            array set tev [twapi::twine $tracerpt_keys $tracerpt_event]
            # Note fields in tev depend on Windows version
            foreach {fld tfld} {
                {task_name {Event Name}}
                {opcode_name Type}
                {id {Event ID}}
                {version Version}
                {channel Channel}
                {level Level}
                {opcode Opcode}
                {task Task}
                {keyword Keyword}
                {pid PID}
                {tid TID}
                {timestamp Clock-Time}
            } {
                if {[info exists tev($tfld)] &&
                    $tev($tfld) != [twapi::etw_event $fld $ev]} {
                    error "Event field $fld value ([twapi::etw_event $fld $ev]) does not match tracerpt value $tev($tfld)"
                }
            }
            foreach {fld tfld} {
                {kernel_time Kernel(ms)}
                {user_time User(ms)}
            } {
                if {[info exists tev($tfld)] &&
                    ($tev($tfld) != [etw_event $fld $ev]/10000)} {
                    error "Event field $fld value ([etw_event $fld $ev]) does not match tracerpt value $tev($tfld)/10000"
                }
            }

            # Unfortunately, cannot check user data as tracerpt will happily skip complex fields like timezone
            if {0 && [info exists "tev(User Data)"]} {
                foreach tdata $tev(User Data) {fld val} [twapi::etw_event properties $ev] {
                    if {$tdata != $val} {
                        error "User data $fld=$val does not match tracerpt value $tdata"
                    }
                }
            }
        }
    }

    test etw_install_mof-1.0 {
        TBD - etw_install_mof
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_uninstall_mof-1.0 {
        TBD - etw_uninstall_mof
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_twapi_provider_register-1.0 {
        TBD - etw_register_provider
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_log_message-1.0 {
        TBD - etw_log_message
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_variable_tracker-1.0 {
        TBD - etw_variable_tracker
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_execution_tracker-1.0 {
        TBD - etw_execution_tracker
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_command_tracker-1.0 {
        TBD - etw_command_tracker
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_parse_mof_event_class-1.0 {
        TBD - etw_parse_mof_event_class
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_find_mof_event_classes-1.0 {
        TBD - etw_find_mof_event_classes
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_get_all_mof_event_classes-1.0 {
        TBD - etw_get_all_mof_event_classes
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_load_mof_event_class_obj-1.0 {
        TBD - etw_load_mof_event_class_obj
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_load_mof_event_classes-1.0 {
        TBD - etw_load_mof_event_classes
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_open_file-1.0 {
        etw_open_file
    } -body {
        set etw [twapi::etw_open_file kernel.etl]
    } -cleanup {
        twapi::etw_close_session $etw
    } -result {\d+} -match regexp

    test etw_open_file-2.0 {
        etw_open_file non-existing file
    } -body {
        set etw [twapi::etw_open_file nosuchfile.etl]
    } -result TBD -returnCodes error

    test etw_open_file-100.0 {
        TBD - etw_open_file        
    } -constraints {
        TBD
    } -body {
        # 32 bit file on 64 bits
        # 64 bit file on 32 bits
        # mof based providers
        # manifest based providers
    } -result TBD

    test etw_open_session-1.0 {
        TBD - etw_open_session
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_close_session-1.0 {
        etw_close_session (file)
    } -body {
        twapi::etw_close_session [twapi::etw_open_file kernel.etl]
    } -result ""

    test etw_close_session-2.0 {
        etw_close_session (real time)
    } -constraints {
        privileged
    } -body {
        
    } -result TBD

    test etw_close_session-3.0 {
        etw_close_session (previously closed)
    } -setup {
        set etw [twapi::etw_open_file kernel.etl]
        twapi::etw_close_session $etw
    } -body {
        twapi::etw_close_session $etw
    } -result "" -returnCodes error

    test etw_consumer-1.0 {
        Test etw_process_events/etw_format_events
    } -setup {
        set etw [twapi::etw_open_file kernel.etl]
        set formatter [twapi::etw_open_formatter]
    } -body {
        set l [twapi::etw_process_events $etw]
        foreach {buf events} $l {
            validate_buf $buf kernel.etl
        }
        validate_events [twapi::etw_format_events $formatter {*}$l] kernel.etl
    } -cleanup {
        twapi::etw_close_formatter $formatter
        twapi::etw_close_session $etw
    } -result ""


    proc process_events_cb {formatter logfile varname bufd events} {
        validate_buf $bufd $logfile
        lappend $varname {*}[twapi::etw_format_events $formatter $bufd $events]
    }

    test etw_consumer-2.0 {
        Test etw_process_events/etw_format_events - callback
    } -setup {
        set etw [twapi::etw_open_file kernel.etl]
        set formatter [twapi::etw_open_formatter]
    } -body {
        set varname ::etw_consumer_[clock microseconds]
        set l [twapi::etw_process_events -callback [list [namespace current]::process_events_cb $formatter kernel.etl $varname] $etw]
        validate_events [set $varname] kernel.etl
        set l
    } -cleanup {
        twapi::etw_close_formatter $formatter
        twapi::etw_close_session $etw
    } -result ""


    test etw_consumer-100.0 {
        TBD - etw_process_events
    } -constraints {
        TBD
    } -body {
        # 32 bit file on 64 bits
        # 64 bit file on 32 bits
        # mof based providers
        # manifest based providers
        # Callback mode
        # MUltiple trace files
        # -starttime, -endtime
    } -result TBD

    test etw_format_events-1.0 {
        TBD - etw_format_events
    } -constraints {
        TBD
    } -body {
        # 32 bit file on 64 bits
        # 64 bit file on 32 bits
        # mof based providers
        # manifest based providers
    } -result TBD

    test etw_dump_files-1.0 {
        TBD - etw_dump_files
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_start_trace-1.0 {
        TBD - etw_start_trace
    } -constraints {
        TBD
    } -body {
        etw_start_trace "NT Kernel Logger" -logfile k.etl -filemodecircular -maximumfilesize 1
    } -result TBD

    test etw_start_kernel_trace-1.0 {
        Start kernel trace (basic)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        twapi::etw_start_kernel_trace {} -logfile $etl
        twapi::etw_stop_trace -sessionname "NT Kernel Logger"
        file exists $etl
    } -result 1

    test etw_start_kernel_trace-2.0 {
        Start kernel trace (verify -filemode default is circular)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl
        after 1000
        # Next command will fail if file mode was not circular as
        # log would get full and the trace would have already stopped
        twapi::etw_stop_trace -sessionname "NT Kernel Logger"
        file size $etl
    } -result 1048576

    test etw_start_kernel_trace-2.1 {
        Start kernel trace (verify -filemode circular)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl
        after 1000
        # Next command will fail if file mode was not circular as
        # log would get full and the trace would have already stopped
        twapi::etw_stop_trace -sessionname "NT Kernel Logger"
        file size $etl
    } -result 1048576

    test etw_start_kernel_trace-2.2 {
        Start kernel trace (verify -filemode sequential)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl -filemode sequential
        after 1000
        twapi::etw_stop_trace -sessionname "NT Kernel Logger"
        expr {[file size $etl] > 1048576}
    } -result 1

    test etw_start_kernel_trace-2.3 {
        Start kernel trace (verify -filemode sequential -maxfilesize)
    } -constraints {
        privileged
    } -body {
        set etl [new_etl_filepath]
        twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl -filemode sequential -maxfilesize 1
        after 1000
        # stop command should as file mode is sequential and
        # log would get full and the trace would have already stopped
        list [catch {twapi::etw_stop_trace -sessionname "NT Kernel Logger"}] \
            [file size $etl]
    } -result {1 1048576}

    test etw_start_kernel_trace-2.4 {
        Start kernel trace (verify -filemode rotate)
    } -constraints {
        privileged
    } -body {
        set etl [file join $logdir [clock microseconds]-%d.etl]
        list [catch {twapi::etw_start_kernel_trace {registry diskio diskfileio} -logfile $etl -filemode rotate}] [errorcode]
    } -result {1 {TWAPI_WIN32 87}}


    test etw_provider-1.0 {
        Tests etw_start_trace/etw_stop_trace/etw_update_trace/etw_log_message/etw_enable_trace/etw_disable_trace
    } -constraints {
        privileged
    } -setup {
        twapi::etw_install_twapi_mof
    } -body {
        set etl [new_etl_filepath]
        set tracename "TWAPITEST_[clock microseconds]"
        set htrace [twapi::etw_start_trace $tracename -logfile $etl]
        set hprov [twapi::etw_twapi_provider_register]
        twapi::etw_enable_trace_provider $htrace [twapi::etw_twapi_provider_guid] -1 5
        after 500;              # Needs a bit of time to take effect
        for {set level 5} {$level > 0} {incr level -1} {
            twapi::etw_enable_trace_provider $htrace [twapi::etw_twapi_provider_guid] -1 $level
            twapi::etw_log_message $hprov "default"
            twapi::etw_log_message $hprov "1" 1
            twapi::etw_log_message $hprov "2" 2
            twapi::etw_log_message $hprov "3" 3
            twapi::etw_log_message $hprov "4" 4
            twapi::etw_log_message $hprov "5" 5

            twapi::etw_flush_trace -sessionhandle $htrace
        }

        # Repeat using tokens for levels
        foreach level {verbose informational warning error fatal} {
            twapi::etw_enable_trace_provider $htrace [twapi::etw_twapi_provider_guid] -1 $level
            twapi::etw_log_message $hprov "default"
            twapi::etw_log_message $hprov "fatal" fatal
            twapi::etw_log_message $hprov "error" error
            twapi::etw_log_message $hprov "warning" warning
            twapi::etw_log_message $hprov "informational" informational
            twapi::etw_log_message $hprov "verbose" verbose
            
            twapi::etw_flush_trace -sessionname $tracename
        }

        # Now disable the provider and try to log
        twapi::etw_disable_trace_provider $htrace [twapi::etw_twapi_provider_guid]
        twapi::etw_log_message $hprov "fatal (provider disabled)" 1
        twapi::etw_flush_trace -sessionhandle $htrace
        twapi::etw_stop_trace -sessionhandle $htrace

        # Now see if messages were logged as expected
        set errors {}
        set htrace [twapi::etw_open_file $etl]
        set formatter [twapi::etw_open_formatter]
        set events [twapi::etw_format_events $formatter {*}[twapi::etw_process_events $htrace]]
        twapi::etw_close_formatter $formatter
        set result {}
        foreach event $events {
            if {[twapi::etw_event provider_name $event] eq "TwapiETWProvider"} {
                lappend result [dict get [twapi::etw_event properties $event] Message]
            }
        }
        set result
    } -result {default 1 2 3 4 5 default 1 2 3 4 default 1 2 3 1 2 1 default fatal error warning informational verbose default fatal error warning informational fatal error warning fatal error fatal}

    test etw_enable_trace-1.0 {
        TBD - etw_enable_trace
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_disable_trace-1.0 {
        TBD - etw_disable_trace
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_control_trace-1.0 {
        TBD - etw_control_trace
    } -constraints {
        TBD
    } -body {
    } -result TBD

    test etw_query_trace-1.0 {
        TBD - etw_query_trace
    } -constraints {
        TBD
    } -body {
    } -result TBD
}

#
# Clean up
catch {twapi::etw_uninstall_twapi_mof}
::tcltest::cleanupTests
namespace delete ::twapi::etw::test
