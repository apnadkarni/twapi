#
# Copyright (c) 2003-2010, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license

# This file contains tests for commands from the share.tcl

package require tcltest
eval tcltest::configure $argv

source [file join [file dirname [info script]] testutil.tcl]
load_twapi

namespace eval twapi::network::test {
    namespace import ::tcltest::test

    ::tcltest::testConstraint win2k [twapi::min_os_version 5]

    variable get_tcp_connections_fields {
        -state
        -localaddr
        -remoteaddr
        -localport
        -remoteport
        -pid
        -modulename
        -modulepath
        -bindtime
    }

    variable get_udp_connections_fields {
            -localaddr
            -localport
            -pid
            -modulename
            -modulepath
            -bindtime
    }


    proc validate_netif_indices {indices} {
        foreach i $indices {
            if {![string is integer $i]} {return 0}
        }
        return 1
    }

    proc resolvable_hostname {} {
        return www.yahoo.com
    }

    proc resolvable_address {} {
        return 209.131.36.158;          # A yahoo address
    }

    proc resolvable_address_domain {} {
        return yahoo.com
    }

    # Validate a connection
    # fields, if present, specifies fields that must be present
    # matchdata, if present, specifies field values that must match
    proc validate_connection [list conndata \
                                  [list fields $get_tcp_connections_fields] \
                                  [list matchdata {}]] {
        if {[llength $fields]} {
            verify_kl_fields $conndata $fields false
        }
        array set match $matchdata
        array set conn $conndata
        # state does not exist for UDP, only TCP
        if {[info exists conn(-state)]} {
            if {[string is integer -strict $conn(-state)]} {
                if {$conn(-state) <= 0 || $conn(-state) >= 13} {
                    return "Invalid connection state $conn(-state)"
                }
            } else {
                if {![info exists ::twapi::tcp_statevalues($conn(-state))]} {
                    return "Invalid connection state $conn(-state)"
                }
            }
        }

        if {[info exists conn(-remoteaddr)]
            && ![valid_ip_address $conn(-remoteaddr)]} {
            return "Invalid remote address $conn(-remoteaddr)"
        }
        if {[info exists conn(-localaddr)]
            && ![valid_ip_address $conn(-localaddr)]} {
            return "Invalid local address $conn(-localaddr)"
        }

        if {[info exists conn(-remoteport)]} {
            if {(![string is integer -strict $conn(-remoteport)]) ||
                ($conn(-remoteport) < 0 || $conn(-remoteport) > 65535)} {
                return "Invalid remote port $conn(-remoteport)"
            }
        }
        if {[info exists conn(-localport)]} {
            if {(![string is integer -strict $conn(-localport)]) ||
                ($conn(-localport) < 0 || $conn(-localport) > 65535)} {
                return "Invalid local port $conn(-localport)"
            }
        }
        # Note on some platforms, PID not available, and empty string is
        # returned
        if {[info exists conn(-pid)] && $conn(-pid) ne ""} {
            # TBD - should we do a process exist check ? But it might have
            # gone away
            if {(! [string is integer $conn(-pid)])
                || $conn(-pid) < 0 || $conn(-pid) > 32000} {
                return "Invalid PID '$conn(-pid)'"
            }
        }

        # Verify any specified fields that should match
        foreach {opt val} $matchdata {
            if {![info exists conn($opt)]} {
                return "Field $opt was expected to contain $val, but did not exist."
            }
            if {$val ne $conn($opt)} {
                return "Field $opt value is '$conn($opt)', expected '$val'"
            }
        }

        return
    }

    proc validate_connections [list conns \
                                   [list mincount 1] \
                                   [list fields $get_tcp_connections_fields] \
                                  [list matchdata {}]] {
        if {[llength $conns] < $mincount} {
            return "Connection list contains only [llength $conns] connections. Expected at least $mincount"
        }
        foreach conn $conns {
            set msg [validate_connection $conn $fields $matchdata]
            if {$msg ne ""} {
                return $msg
            }
        }
        return ""
    }

    ################################################################

    test get_ip_addresses-1.0 {
        Get IP addresses
    } -constraints {
        nt
    } -body {
        expr {[lsearch [twapi::get_ip_addresses] 127.0.0.1] >= 0}
    } -result 1

    ################################################################

    test get_netif_indices-1.0 {
        Get network interface indices
    } -constraints {
        nt
    } -body {
        set indices [twapi::get_netif_indices]
        set bad_indices [list ]
        foreach i $indices {
            if {! [string is integer $i]} {
                lappend bad_indices $i
            }
        }
        set bad_indices
    } -result ""

    ################################################################

    test get_network_info-1.0 {
        Get all network information
    } -constraints {
        nt
    } -body {
        if {[twapi::min_os_version 5]} {
            array unset netinfo
            array set netinfo [twapi::get_network_info -all]
            verify_kl_fields [array get netinfo] {
                -arpproxyenabled -dhcpscopeid -dnsenabled -dnsservers
                -domain -hostname -interfaces -ipaddresses -routingenabled
            }
            expr {
                  [string is boolean $netinfo(-arpproxyenabled)] &&
                  [string is boolean $netinfo(-dnsenabled)] &&
                  [validate_ip_addresses $netinfo(-dnsservers)] &&
                  [validate_netif_indices $netinfo(-interfaces)] &&
                  [validate_ip_addresses $netinfo(-ipaddresses)] &&
                  [string is boolean $netinfo(-routingenabled)]
              }
        } else {
            # NT 4 - command should throw an error
            set result [catch {twapi::get_network_info -all} msg]
        }
    } -result 1

    ################################################################

    set testnum 1
    foreach {field validation} {
        -arpproxyenabled "string is boolean"
        -dhcpscopeid     "string match *"
        -dnsenabled      "string is boolean"
        -dnsservers      "validate_ip_addresses"
        -domain          "string match *"
        -hostname        "string match *"
        -interfaces      "validate_netif_indices"
        -ipaddresses     "validate_ip_addresses"
        -routingenabled  "string is boolean"
    } {
        test get_network_info-[incr testnum].0 "Verify get_network_info $field" -constraints {
            nt win2k
        } -body "
            set result \[twapi::get_network_info $field \]
            verify_kl_fields \$result [list $field]
            eval \$validation \[list \[lindex \$result 1\] \]
        " -result 1
    }

    ################################################################

    test get_netif_info-1.0 {
    } -constraints {
        nt TBD
    } -setup {
    } -body {
    } -cleanup {
    } -result ""

    ################################################################

    test hostname_to_address-1.0 {
        Map host name to address
    } -constraints {
        nt
    } -body {
        set ipaddrs [twapi::hostname_to_address [resolvable_hostname]]
        expr {[llength $ipaddrs] && [validate_ip_addresses $ipaddrs]}
    } -result 1

    ###

    test hostname_to_address-1.1 {
        Map host name to address (no addresses)
    } -constraints {
        nt
    } -body {
        llength [twapi::hostname_to_address xadf.xtrt.xsfdg.com]
    } -result 0

    ###

    test hostname_to_address-2.0 {
        Map host name to address asynchronous (success)
    } -constraints {
        nt
    } -body {
        set ::hostname_to_address_result [list ]
        twapi::hostname_to_address [resolvable_hostname] -async {lappend ::hostname_to_address_result}
        vwait ::hostname_to_address_result
        foreach {hostname status ipaddrs} $::hostname_to_address_result break
        expr {($hostname eq "[resolvable_hostname]") && ($status eq "success") && [llength $ipaddrs] && [validate_ip_addresses $ipaddrs]}
    } -result 1

    ###

    test hostname_to_address-2.1 {
        Map host name to address asynchronous (no addresses)
    } -constraints {
        nt
    } -body {
        set ::hostname_to_address_result [list ]
        twapi::hostname_to_address xno.xsuch.xname.xcom -async {lappend ::hostname_to_address_result}
        vwait ::hostname_to_address_result
        foreach {hostname status ipaddrs} $::hostname_to_address_result break
        expr {
	      $hostname eq "xno.xsuch.xname.xcom" &&
	      ((($status eq "success") && [llength $ipaddrs] == 0) ||
	       $status eq "fail")
	   }
    } -result 1

    ###

    test hostname_to_address-3.0 {
        Map host name to address -flushcache
    } -constraints {
        nt
    } -setup {
        # Prepopulate cache
        twapi::hostname_to_address [resolvable_hostname]
	puts "This test make take upto a minute"
    } -body {
        set cache_lookup [time {twapi::hostname_to_address [resolvable_hostname]}]
        # Wait for 30 seconds since Windows also keep a cache and that
        # must flush else we cannot tell if our internal cache was flushed
        # TBD - replace with some quicker means
        after 30000
        set nocache_lookup [time {set ipaddrs [twapi::hostname_to_address [resolvable_hostname] -flushcache]}]
        expr {[llength $ipaddrs] &&
              [validate_ip_addresses $ipaddrs] &&
              [lindex $cache_lookup 0] < 50 &&
              [lindex $nocache_lookup 0] > 100
          }
    } -result 1

    ################################################################

    test address_to_hostname-1.0 {
        Map address to host name
    } -constraints {
        nt
    } -body {
        twapi::address_to_hostname [resolvable_address]
    } -match glob -result *[resolvable_address_domain]

    ###

    test address_to_hostname-1.1 {
        Map address to host name (no names)
    } -constraints {
        nt
    } -body {
        llength [twapi::address_to_hostname 127.0.0.2]
    } -result 0

    ###

    test address_to_hostname-1.2 {
        Map 127.0.0.1
    } -constraints {
        nt
    } -body {
        set name [twapi::address_to_hostname 127.0.0.1]
        expr {[string equal -nocase $name localhost] ||
              [string equal -nocase $name $::env(COMPUTERNAME)]}
    } -result 1

    ###

    test address_to_hostname-2.0 {
        Map address to host name asynchronous (success)
    } -constraints {
        nt
    } -body {
        set ::address_to_hostname_result [list ]
        twapi::address_to_hostname [resolvable_address] -async {lappend ::address_to_hostname_result}
        vwait ::address_to_hostname_result
        foreach {addr status hostname} $::address_to_hostname_result break
        expr {($addr eq [resolvable_address]) && ($status eq "success") && [string match *[resolvable_address_domain] $hostname]}
    } -result 1

    ###

    test address_to_hostname-2.1 {
        Map address to host name asynchronous (no addresses)
    } -constraints {
        nt
    } -body {
        set ::address_to_hostname_result [list ]
        twapi::address_to_hostname 127.0.0.2 -async {lappend ::address_to_hostname_result}
        vwait ::address_to_hostname_result
        foreach {addr status hostname} $::address_to_hostname_result break
        expr {($addr eq "127.0.0.2") && ($status eq "success") && $hostname eq ""}
    } -result 1

    ###

    test address_to_hostname-3.0 {
        Map address to host name -flushcache
    } -constraints {
        nt
    } -setup {
        # Prepopulate cache
        twapi::address_to_hostname [resolvable_address]
    } -body {
        set addr [resolvable_address]
        set cache_lookup [time {twapi::address_to_hostname $addr}]
        # Wait for 30 seconds since Windows also keep a cache and that
        # must flush else we cannot tell if our internal cache was flushed
        # TBD - replace with some quicker means
        after 30000
        set nocache_lookup [time {set hostname [twapi::address_to_hostname $addr -flushcache]}]
        expr {[string match *[resolvable_address_domain] $hostname] &&
              [lindex $cache_lookup 0] < 50 &&
              [lindex $nocache_lookup 0] > 100
          }
    } -result 1

    ################################################################

    test port_to_service-1.0 {
        Map port number to service name
    } -constraints {
        nt
    } -body {
        twapi::port_to_service 80
    } -result http

    ###

    test port_to_service-1.1 {
        Map port number to service name (non-existent)
    } -constraints {
        nt
    } -body {
        twapi::port_to_service 1234
    } -result ""

    ################################################################

    test service_to_port-1.0 {
        Map service to port number
    } -constraints {
        nt
    } -body {
        twapi::service_to_port http
    } -result 80

    ###

    test service_to_port-1.1 {
        Map service to port (non-existent)
    } -constraints {
        nt
    } -body {
        twapi::service_to_port httpx
    } -result ""

    ###

    test service_to_port-1.2 {
        Map service to port (numeric)
    } -constraints {
        nt
    } -body {
        twapi::service_to_port 80
    } -result 80

    ################################################################

    test get_tcp_connections-1.0 {
        Get TCP connections
    } -constraints {
        nt
    } -body {
        validate_connections [twapi::get_tcp_connections -all] 1
    } -result ""

    ###

    test get_tcp_connections-2.0 {
        Get TCP connections -modulepath
    } -setup {
        # Make sure at least one connection established
        set server_socket [socket -server [list set ::connection_establised 1] 9341]
        set client_socket [socket 127.0.0.1 9341]
    } -body {
        array set conns [lindex [twapi::get_tcp_connections -all -matchlocalport 9341] 0]
        set conns(-modulepath)
    } -cleanup {
        close $client_socket
        close $server_socket
    } -result [info nameofexecutable] -match path

    test get_tcp_connections-2.1 {
        Get TCP connections -modulename
    } -setup {
        # Make sure at least one connection established
        set server_socket [socket -server [list set ::connection_establised 1] 9341]
        set client_socket [socket 127.0.0.1 9341]
    } -body {
        array set conns [lindex [twapi::get_tcp_connections -all -matchlocalport 9341] 0]
        set conns(-modulename)
    } -cleanup {
        close $client_socket
        close $server_socket
    } -result [file tail [info nameofexecutable]] -match path

    set testnum 1
    foreach opt $get_tcp_connections_fields {
        test get_tcp_connections-2.[incr testnum] "get_tcp_connections $opt" -body "validate_connections \[twapi::get_tcp_connections $opt\] 1 $opt" -result ""}

    test get_tcp_connections-3.0 {
        get_tcp_connections -matchstate listen
    } -body {
        validate_connections [twapi::get_tcp_connections -all -matchstate listen] 1 $get_tcp_connections_fields [list -state listen]
    } -result ""

    test get_tcp_connections-3.1 {
        get_tcp_connections -matchstate estab
    } -setup {
        # Make sure at least one connection established
        set server_socket [socket -server [list set ::connection_establised 1] 9341]
        set client_socket [socket 127.0.0.1 9341]
    } -body {
        validate_connections [twapi::get_tcp_connections -all -matchstate estab] 1 $get_tcp_connections_fields [list -state estab]
    } -cleanup {
        close $client_socket
        close $server_socket
    } -result ""

    test get_tcp_connections-3.2 {
        get_tcp_connections -matchstate close_wait
    } -setup {
        # Make sure at least one connection established
        set server_socket [socket -server [list set ::connection_establised 1] 9342]
        set client_socket [socket 127.0.0.1 9342]
    } -body {
        close $client_socket;   # Should put in close_wait state
        validate_connections [twapi::get_tcp_connections -all -matchstate close_wait] 1 $get_tcp_connections_fields [list -state close_wait]
    } -cleanup {
        close $server_socket
    } -result ""

    # For the following, it's hard to guarantee connection state, so min
    # value for number of connections is 0
    set testnum 2
    foreach state {closed syn_sent syn_rcvd fin_wait1 fin_wait2 closing last_ack time_wait delete_tcb} {
        test get_tcp_connections-3.[incr testnum] "get_tcp_connections -all -matchstate $state" -body "validate_connections \[twapi::get_tcp_connections -all -matchstate $state\] 0 [list $get_tcp_connections_fields] {-state $state}" -result ""}

    set testnum 3
    foreach {matchopt opt val} [list \
                                    -matchlocaladdr -localaddr 127.0.0.1 \
                                    -matchremoteaddr -remoteaddr 127.0.0.1 \
                                    -matchlocalport -localport 9341 \
                                    -matchremoteport -remoteport 9341 \
                                    -matchpid -pid  [pid]] {
        test get_tcp_connections-[incr testnum].0 \
            "get_tcp_connections -all $matchopt $val" \
            -setup {
                set server_socket [socket -server [list lappend ::connection_establised 1] 9341]
                set client_socket [socket 127.0.0.1 9341]
            } -body "validate_connections \[twapi::get_tcp_connections -all $matchopt $val\] 1 [list $get_tcp_connections_fields] {$opt $val}" \
            -cleanup {
                close $client_socket
                close $server_socket
            } -result ""
    }


    ################################################################

    test get_udp_connections-1.0 {
        Get UDP connections
    } -body {
        validate_connections [twapi::get_udp_connections -all] 1 $get_udp_connections_fields
    } -result ""

    test get_udp_connections-2.0 {
        Get UDP connections -modulepath
    } -body {
        array set conns [lindex [twapi::get_udp_connections -all -matchlocalport 1900] 0]
        set conns(-modulepath)
    } -result [file join $::env(WINDIR) system32 kernel32.dll] -match path

    test get_udp_connections-2.1 {
        Get UDP connections -modulename
    } -body {
        array set conns [lindex [twapi::get_udp_connections -all -matchlocalport 1900] 0]
        set conns(-modulename)
    } -result kernel32.dll -match path

    set testnum 1
    foreach opt $get_udp_connections_fields {
        test get_udp_connections-2.[incr testnum] "get_udp_connections $opt" -body "validate_connections \[twapi::get_tcp_connections $opt\] 1 $opt" -result ""}

    set testnum 2
    foreach {matchopt opt val} [list \
                                    -matchlocaladdr -localaddr 127.0.0.1 \
                                    -matchlocalport -localport 1900 \
                                    -matchpid -pid  [lindex [lindex [twapi::get_udp_connections -pid -matchlocalport 123] 0] 1]] {
        test get_udp_connections-[incr testnum].0 {
            get_udp_connections -all $matchopt $val
        } -body "validate_connections \[twapi::get_udp_connections -all $matchopt $val\] 1 [list $get_udp_connections_fields] {$opt $val}" \
            -result ""
    }

    ################################################################

    test terminate_tcp_connections-1.0 {
        Terminate TCP connections for a specific process (-matchpid)
    } -setup {
        set nconns [llength [twapi::get_tcp_connections -pid]]
        set server_socket [socket -server [list lappend ::connection_establised 1] 9341]
        set client_socket [socket 127.0.0.1 9341]
        set client_socket2 [socket 127.0.0.1 9341]
    } -body {
        # Assumes no other extraneous connections are created on the system
        twapi::terminate_tcp_connections -matchpid [pid]
        set conns [twapi::get_tcp_connections -pid]
        # Both active connections should be gone (server listen socket
        # will still be present). This also verifies somewhat that
        # we did not kill connections from other processes.
        list [expr {[llength $conns]-$nconns}] \
            [twapi::get_tcp_connections -pid -matchpid [pid]]
    } -cleanup {
        close $client_socket
        close $client_socket2
        close $server_socket
    } -result [list 1 [list [list -pid [pid]]]]

    test terminate_tcp_connections-2.0 {
        Terminate TCP connections for a remote port (-matchremoteport)
    } -setup {
        set nconns [llength [twapi::get_tcp_connections -pid]]
        set server_socket [socket -server [list lappend ::connection_establised 1] 9341]
        set server_socket2 [socket -server [list lappend ::connection_establised 1] 9342]
        set client_socket [socket 127.0.0.1 9341]
        set client_socket2 [socket 127.0.0.1 9342]
    } -body {
        # Assumes no other extraneous connections are created on the system
        twapi::terminate_tcp_connections -matchremoteport 9342
        set conns [twapi::get_tcp_connections -pid]
        # One active connections should be gone (both server listen socket
        # will still be present). This also verifies somewhat that
        # we did not kill connections from other processes.
        list [expr {[llength $conns]-$nconns}] \
            [twapi::get_tcp_connections -pid -matchpid [pid]]
    } -cleanup {
        close $server_socket
        close $server_socket2
        close $client_socket
        close $client_socket2
    } -result [list 4 [list [list -pid [pid]] [list -pid [pid]] [list -pid [pid]] [list -pid [pid]]] ]

    test terminate_tcp_connections-3.0 {
        Terminate TCP connections for a remote address (-matchremoteaddress)
    } -setup {
        foreach {addrA addrB} [twapi::get_ip_addresses] break
        set nconns [llength [twapi::get_tcp_connections -pid]]
        set server_socket [socket -server [list lappend ::connection_establised 1] -myaddr $addrA 9341]
        set server_socket2 [socket -server [list lappend ::connection_establised 1] -myaddr $addrB 9342]
        set client_socket [socket $addrA 9341]
        set client_socket2 [socket $addrB 9342]
    } -body {
        # Assumes no other extraneous connections are created on the system
        twapi::terminate_tcp_connections -matchremoteaddr $addrA
        set conns [twapi::get_tcp_connections -pid]
        # One active connections should be gone (both server listen socket
        # will still be present). This also verifies somewhat that
        # we did not kill connections from other processes.
        list [expr {[llength $conns]-$nconns}] \
            [twapi::get_tcp_connections -pid -matchpid [pid]]
    } -cleanup {
        close $server_socket
        close $server_socket2
        close $client_socket
        close $client_socket2
    } -result [list 4 [list [list -pid [pid]] [list -pid [pid]] [list -pid [pid]] [list -pid [pid]]] ]

    test terminate_tcp_connections-4.0 {
        Terminate TCP connections for a local address (-matchlocaladdress)
    } -setup {
        foreach {addrA addrB} [twapi::get_ip_addresses] break
        set nconns [llength [twapi::get_tcp_connections -pid]]
        set server_socket [socket -server [list lappend ::connection_establised 1] -myaddr $addrA 9341]
        set server_socket2 [socket -server [list lappend ::connection_establised 1] -myaddr $addrB 9342]
        set client_socket [socket $addrA 9341]
        set client_socket2 [socket $addrB 9342]
    } -body {
        # Assumes no other extraneous connections are created on the system
        twapi::terminate_tcp_connections -matchlocaladdr $addrA
        set conns [twapi::get_tcp_connections -pid]
        # One active connections should be gone (both server listen socket
        # will still be present). This also verifies somewhat that
        # we did not kill connections from other processes.
        list [expr {[llength $conns]-$nconns}] \
            [twapi::get_tcp_connections -pid -matchpid [pid]]
    } -cleanup {
        close $server_socket
        close $server_socket2
        close $client_socket
        close $client_socket2
    } -result [list 4 [list [list -pid [pid]] [list -pid [pid]] [list -pid [pid]] [list -pid [pid]]] ]

    ################################################################

    ::tcltest::cleanupTests
}

namespace delete ::twapi::network::test
