#
# Copyright (c) 2010, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license

# This file contains tests for commands from the services.tcl

package require tcltest

eval tcltest::configure $argv

source [file join [file dirname [info script]] testutil.tcl]
load_twapi

namespace eval twapi::pipe::test {
    namespace import ::tcltest::test

    # Name to use for test service
    variable pipe_name "twapitest"

    ::tcltest::testConstraint tcl85plus [package vsatisfies [package require Tcl] 8.5]

    # Contains channels for the test servers
    variable servers
    array set servers {}

    # Contains scripts for various test scenarios
    variable scripts
    set scripts(accept) {
        load_twapi
        proc accept {chan} {
            set ::outcome connected
        }
        puts READY
        set timer [after 20000 "set ::outcome timeout"]
	set pipe_fd [::twapi::namedpipe "\\\\.\\pipe\\twapiaccept" -type server]
        fileevent $pipe_fd writable [list accept $pipe_fd]
        vwait ::outcome
        after cancel $timer
        close $pipe_fd
        puts $::outcome
    }

    set scripts(blocking_server) {
        load_twapi
        proc accept {chan} {
            set ::outcome connected
            fileevent $chan writable {}
        }
        proc echoline {} {
            if {[catch {
                set line [gets $::pipe_fd]
                puts $::pipe_fd $line
            } msg]} {
                testlog "echoline: error $msg\n$::errorInfo"
            }
        }
        puts READY
        set timer [after 20000 "set ::outcome timeout"]
	set pipe_fd [::twapi::namedpipe "\\\\.\\pipe\\twapiblockingserver" -type server]
        fconfigure $pipe_fd -buffering line -translation crlf -eofchar {} -encoding utf-8
        fileevent $pipe_fd writable [list accept $pipe_fd]
        vwait ::outcome
        after cancel $timer
        puts $::outcome
    }

    proc start_server {server_type} {
        variable servers
        variable scripts
        if {[info exists servers($server_type)]} {
            return $servers($server_type)
        }

        set fd [tclsh_slave_start]
        tclsh_slave_wait $fd
        # We create a temp file and have the slave tclsh read it.
        # We do NOT write the commands to $fd as then the slave reads
        # from there a line at a time in async mode, causing sequential
        # code to become non-sequential in the presence of vwaits etc.
        puts $fd [list source [tcltest::makeFile $scripts($server_type) twapi_test_accept]]
        expect $fd READY 5000
        set servers($server_type) $fd
        return $fd
    }

    proc stop_server {server_type} {
        variable servers
        if {[info exists servers($server_type)]} {
            tclsh_slave_stop $servers($server_type)
            unset servers($server_type)
        }
    }

    # Opens a client side pipe using Tcl's open command
    proc open_tcl_pipe {pipe {mode w+}} {
        # Wait up to 5 second since remote process might not have started
        set elapsed 0
        while {$elapsed < 5000} {
            if {[catch {
                open $pipe $mode
            } fd]} {
                after 100;      # Wait 100ms
                incr elapsed 100
            } else {
                return $fd
            }
        }
        error "Could not open pipe to $pipe"
    }
    proc close_tcl_pipe chan {
        # Need to catch closing of the client side pipe since Tcl
        # closes the handle twice in the pipe channel handler, probably
        # because it is not written for named pipes.
        catch {close $chan}
    }


    ################################################################

    test pipe-server-1.0 {
        Open a named pipe as server
    } -setup {
        set control_channel [start_server accept]
    } -constraints {
        nt
    } -body {
        set pipe [open_tcl_pipe "\\\\.\\pipe\\twapiaccept"]
        tclsh_slave_gets $control_channel
    } -cleanup {
        if {[info exists pipe]} {close_tcl_pipe $pipe}
        stop_server accept
    } -result connected

    ################################################################

    test pipe-server-2.0 {
        Test server using blocking I/O
    } -setup {
        set control_channel [start_server blocking_server]
    } -constraints {
        nt
    } -body {
        set pipe [open_tcl_pipe "\\\\.\\pipe\\twapiblockingserver"]
        fconfigure $pipe -blocking 0 -buffering line -translation crlf -eofchar {} -encoding utf-8
        expect $control_channel "connected"
        set result ""
        for {set i 1} {$i < 2000} {set i [expr {$i + ($i+1)/2}]} {
            puts $control_channel {echoline}
            set request [string repeat "a" $i] 
            puts $pipe $request
            set response [gets_timeout $pipe 60000]
            if {[string compare $request $response]} {
                set result "Mismatch with string length $i"
                break
            }
        }
        set result
    } -cleanup {
        if {[info exists pipe]} {close_tcl_pipe $pipe}
        stop_server blocking_server
    } -result ""


    ################################################################


    ::tcltest::cleanupTests
}

namespace delete ::twapi::pipe::test
