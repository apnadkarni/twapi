#
# Copyright (c) 2013, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license

# This file contains tests for twapi TLS commands
# Most of this forked from the Tcl TLS extension tests tlsIO.test file
# Therefore it does not follow the structure of the other TWAPI test files.


# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
# Copyright (c) 1998-2000 Ajuba Solutions. 
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: tlsIO.test,v 1.23 2008/03/19 22:06:13 hobbs2 Exp $

# Running socket tests with a remote server:
# ------------------------------------------
# 
# Some tests in socket.test depend on the existence of a remote server to
# which they connect. The remote server must be an instance of tcltest and it
# must run the script found in the file "remote.tcl" in this directory. You
# can start the remote server on any machine reachable from the machine on
# which you want to run the socket tests, by issuing:
# 
#     tcltest remote.tcl -port 8048	# Or choose another port number.
# 
# If the machine you are running the remote server on has several IP
# interfaces, you can choose which interface the server listens on for
# connections by specifying the -address command line flag, so:
# 
#     tcltest remote.tcl -address your.machine.com
# 
# These options can also be set by environment variables. On Unix, you can
# type these commands to the shell from which the remote server is started:
# 
#     shell% setenv serverPort 8048
#     shell% setenv serverAddress your.machine.com
# 
# and subsequently you can start the remote server with:
# 
#     tcltest remote.tcl
# 
# to have it listen on port 8048 on the interface your.machine.com.
#     
# When the server starts, it prints out a detailed message containing its
# configuration information, and it will block until killed with a Ctrl-C.
# Once the remote server exists, you can run the tests in socket.test with
# the server by setting two Tcl variables:
# 
#     % set remoteServerIP <name or address of machine on which server runs>
#     % set remoteServerPort 8048
# 
# These variables are also settable from the environment. On Unix, you can:
# 
#     shell% setenv remoteServerIP machine.where.server.runs
#     shell% setenv remoteServerPort 8048
# 
# The preamble of the socket.test file checks to see if the variables are set
# either in Tcl or in the environment; if they are, it attempts to connect to
# the server. If the connection is successful, the tests using the remote
# server will be performed; otherwise, it will attempt to start the remote
# server (via exec) on platforms that support this, on the local host,
# listening at port 8048. If all fails, a message is printed and the tests
# using the remote server are not performed.

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

eval tcltest::configure $argv


proc dputs {msg} { return ; puts stderr $msg ; flush stderr }

set tlsServerPort 8048

# This sequence is used in spawned processes as well.
# So store it in a var so it can be easily invoked in children
set initScript {
    source [file join [file dirname [info script]] testutil.tcl]
    load_twapi_package twapi_crypto

    proc verifytrue {chan ctx} {return 1}
    proc verifyfalse {chan ctx} {return 0}
    proc verifyerror {chan ctx} {error "Verification error" "" [list TEST TLS VERIFYFAIL]}
    proc verify {remote_name chan ctx} {
        set remote_cert [twapi::sspi_remote_cert $ctx]
        twapi::trap {
            if {$remote_name eq ""} {
                set status [twapi::cert_tls_verify $remote_cert -hstore $::certStore -revocationcheck none -trustedroots [list $::caCert]]
            } else {
                set status [twapi::cert_tls_verify $remote_cert -hstore $::certStore -revocationcheck none -trustedroots [list $::caCert] -server $remote_name]
            }
            return [string equal $status ok]
        } finally {
            twapi::cert_release $remote_cert
        }
    } 


    # Where the certificates are
    set pfxFile [file join [file dirname [info script]] certs twapitest.pfx]
    # Set up the store containing the certificates
    set certStore [twapi::cert_temporary_store -pfx [read_file $pfxFile rb]]
    # Set up the client and server credentials
    set clientCert [twapi::cert_store_find_certificate $certStore subject_substring twapitestclient]
    set serverCert [twapi::cert_store_find_certificate $certStore subject_substring twapitestserver]
    set altserverCert [twapi::cert_store_find_certificate $certStore subject_substring twapitestaltserver]
    set caCert [twapi::cert_store_find_certificate $certStore subject_substring twapitestca]
    # TBD - check if certs can be released as soon as we obtain credentials
    set clientCreds [twapi::sspi_acquire_credentials -credentials [twapi::sspi_schannel_credentials -certificates [list $clientCert]] -package unisp -role client]
    set serverCreds [twapi::sspi_acquire_credentials -credentials [twapi::sspi_schannel_credentials -certificates [list $serverCert]] -package unisp -role server]
    set altserverCreds [twapi::sspi_acquire_credentials -credentials [twapi::sspi_schannel_credentials -certificates [list $altserverCert]] -package unisp -role server]
}
# Set up certs in this process
eval $initScript

# TBD - need to test separate creds for tls1, tls1.1, ssl3 etc.
# TBD - need to test separate creds for -sessionlifespan

#
# Test configuration

# Some tests require the testthread and exec commands

set ::tcltest::testConstraints(testthread) \
	[expr {[info commands testthread] != {}}]
set ::tcltest::testConstraints(exec) [expr {[info commands exec] != {}}]

#
# If remoteServerIP or remoteServerPort are not set, check in the
# environment variables for externally set values.
#

if {![info exists remoteServerIP]} {
    if {[info exists env(remoteServerIP)]} {
	set remoteServerIP $env(remoteServerIP)
    }
}
if {![info exists remoteServerPort]} {
    if {[info exists env(remoteServerPort)]} {
	set remoteServerPort $env(remoteServerPort)
    } else {
        if {[info exists remoteServerIP]} {
	    set remoteServerPort $tlsServerPort
        }
    }
}

# TBD - do_handshake not ported and handshake not implemented by twapi
proc do_handshake {s {type readable} {cmd {}} args} {
    if {[eof $s]} {
	close $s
	dputs "handshake: eof"
	set ::do_handshake "eof"
    } elseif {[catch {tls::handshake $s} result]} {
	# Some errors are normal.
	dputs "handshake: $result"
    } elseif {$result == 1} {
	# Handshake complete
	if {[llength $args]} { eval [list fconfigure $s] $args }
	if {$cmd == ""} {
	    fileevent $s $type ""
	} else {
	    fileevent $s $type "$cmd [list $s]"
	}
	dputs "handshake: complete"
	set ::do_handshake "complete"
    } else {
	dputs "handshake: in progress"
    }
}

#
# Check if we're supposed to do tests against the remote server
#

set doTestsWithRemoteServer 0
if {![info exists remoteServerIP] && ($tcl_platform(platform) != "macintosh")} {
    set remoteServerIP 127.0.0.1
}
if {($doTestsWithRemoteServer == 1) && (![info exists remoteServerPort])} {
    set remoteServerPort $tlsServerPort
}

# Attempt to connect to a remote server if one is already running. If it
# is not running or for some other reason the connect fails, attempt to
# start the remote server on the local host listening on port 8048. This
# is only done on platforms that support exec (i.e. not on the Mac). On
# platforms that do not support exec, the remote server must be started
# by the user before running the tests.

set remoteProcChan ""
set commandSocket ""
if {$doTestsWithRemoteServer == 0} {
    set noRemoteTestReason "doTestsWithRemoteServer initialized to 0"
} else {
    catch {close $commandSocket}
    if {[catch {set commandSocket [twapi::tls_socket -credentials $clientCreds \
                                       $remoteServerIP $remoteServerPort]}] != 0} {
	if {[info commands exec] == ""} {
	    set noRemoteTestReason "can't exec"
	    set doTestsWithRemoteServer 0
	} else {
	    set remoteServerIP 127.0.0.1
	    set remoteFile [file join [pwd] remote.tcl]
	    if {[catch {set remoteProcChan \
		    [open "|[list $::tcltest::tcltest $remoteFile \
		    -serverIsSilent -port $remoteServerPort \
		    -address $remoteServerIP]" w+]} msg] == 0} {
		after 1000
		if {[catch {set commandSocket [twapi::tls_socket -credentials $clientCreds \
                                                   $remoteServerIP $remoteServerPort]} msg] == 0} {
		    fconfigure $commandSocket -translation crlf -buffering line
		} else {
		    set noRemoteTestReason $msg
		    set doTestsWithRemoteServer 0
		}
	    } else {
		set noRemoteTestReason "$msg $::tcltest::tcltest"
		set doTestsWithRemoteServer 0
	    }
	}
    } else {
	fconfigure $commandSocket -translation crlf -buffering line
    }
}

# Some tests are run only if we are doing testing against a remote server.
set ::tcltest::testConstraints(doTestsWithRemoteServer) $doTestsWithRemoteServer
if {$doTestsWithRemoteServer == 0} {
    if {[string first s $::tcltest::verbose] != -1} {
    	puts "Skipping tests with remote server. See [info script] for"
	puts "information on how to run remote server."
	puts "Reason for not doing remote tests: $noRemoteTestReason"
    }
}

#
# If we do the tests, define a command to send a command to the
# remote server.
#

if {$doTestsWithRemoteServer == 1} {
    proc sendCommand {c} {
	global commandSocket

	if {[eof $commandSocket]} {
	    error "remote server disappeared"
	}

	if {[catch {puts $commandSocket $c} msg]} {
	    error "remote server disappeared: $msg"
	}
	if {[catch {puts $commandSocket "--Marker--Marker--Marker--"} msg]} {
	    error "remote server disappeared: $msg"
	}

	set resp ""
	while {1} {
	    set line [gets $commandSocket]
	    if {[eof $commandSocket]} {
		error "remote server disappeared"
	    }
	    if {[string compare $line "--Marker--Marker--Marker--"] == 0} {
		if {[string compare [lindex $resp 0] error] == 0} {
		    error [lindex $resp 1]
		} else {
		    return [lindex $resp 1]
		}
	    } else {
		append resp $line "\n"
	    }
	}
    }

    sendCommand [list proc dputs [info args dputs] [info body dputs]]

    proc TBDsendCertValues {} {
	# We need to be able to send certificate values that normalize
	# filenames across platforms
	sendCommand {
	    set certsDir	[file join [file dirname [info script]] certs]
	    set serverCert	[file join $certsDir server.pem]
	    set clientCert	[file join $certsDir client.pem]
	    set caCert		[file join $certsDir cacert.pem]
	    set serverKey	[file join $certsDir server.key]
	    set clientKey	[file join $certsDir client.key]
	}
    }
}

test tlsIO-1.1 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -server} msg] $msg
} {1 {No value supplied for option '-server'}}

test tlsIO-1.2 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -server foo} msg] $msg
} {1 {Option -credentials must be specified for server sockets}}

test tlsIO-1.3 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -myaddr} msg] $msg
} {1 {No value supplied for option '-myaddr'}}

test tlsIO-1.4 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -myaddr 127.0.0.1} msg] $msg
} {1 {wrong # args: should be "tls_socket ?-credentials creds? ?-verifier command? ?-peersubject peer? ?-myaddr addr? ?-myport myport? ?-async? host port" or "tls_socket ?-credentials creds? ?-verifier command? -server command ?-myaddr addr? port"}}

test tlsIO-1.5 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -myport} msg] $msg
} {1 {No value supplied for option '-myport'}}

test tlsIO-1.6 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -myport xxxx} msg] $msg
} {1 {Non-integer value 'xxxx' specified for option '-myport'}}

test tlsIO-1.7 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -myport 2522} msg] $msg
} {1 {wrong # args: should be "tls_socket ?-credentials creds? ?-verifier command? ?-peersubject peer? ?-myaddr addr? ?-myport myport? ?-async? host port" or "tls_socket ?-credentials creds? ?-verifier command? -server command ?-myaddr addr? port"}}

test tlsIO-1.8 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -froboz} msg] $msg
} {1 {Invalid option '-froboz'. Must be one of -myaddr, -myport, -async, -server, -peersubject, -credentials, -verifier}}

test tlsIO-1.9 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -server foo -myport 2521 3333} msg] $msg
} {1 {Option -credentials must be specified for server sockets}}

test tlsIO-1.10 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket host 2528 -junk} msg] $msg
} {1 {wrong # args: should be "tls_socket ?-credentials creds? ?-verifier command? ?-peersubject peer? ?-myaddr addr? ?-myport myport? ?-async? host port" or "tls_socket ?-credentials creds? ?-verifier command? -server command ?-myaddr addr? port"}}

test tlsIO-1.11 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket -server callback 2520 --} msg] $msg
} {1 {Option -credentials must be specified for server sockets}}

test tlsIO-1.12 {arg parsing for socket command} {socket} {
    list [catch {twapi::tls_socket foo badport} msg] $msg
} {1 {expected integer but got "badport"}}


#
# Basic tests all use the same server script
proc basicServerScript {server_port {creds_varname serverCreds}} {
    return [format {
        %1$s
        proc accept {chan addr port} {
            global x
            set count [gets $chan x]
            if {$count >= 0} {
                switch $x {
                    conninfo {set out [list [list $addr $port] [fconfigure $chan -sockname] [fconfigure $chan -peername]]}
                    default {set out [string reverse $x]}
                }
                puts $chan $out ; flush $chan
            } else {
                set x EOF
            }
            close $chan
        }
        set timer [after 5000 "set x timed_out"]
        set f [twapi::tls_socket -server accept -credentials $::%3$s -verifier verifytrue %2$d]
        puts ready
        vwait x
        after cancel $timer
        close $f
        puts $x
    } $::initScript $server_port $creds_varname]
}


#
# Async tests all use the same server script
proc asyncServerScript {server_port {creds_varname serverCreds}} {
    return [format {
        %1$s
        proc accept {chan addr port} {
            set ::Remote [list $addr $port]
            fconfigure $chan -blocking 0
            fileevent $chan readable [list do $chan]
	    fconfigure $chan -translation lf -buffering line
        }
        proc do {chan} {
            after cancel $::Timer
            set count [gets $chan in]
            if {$count >= 0} {
                lappend ::Received $in
                switch $in {
                    conninfo {puts $chan [list $::Remote [fconfigure $chan -sockname] [fconfigure $chan -peername]]}
                    quit {set ::Gate quit ; close $chan}
                    default {puts $chan [string reverse $in]}
                }
                set Timer [after 5000 "set ::Gate timed_out"]
            } else {
                if {[eof $chan]} {
                    lappend ::Received EOF
                    set ::Gate EOF
                    close $chan
                }
            }
        }
        set Received {}
        set Timer [after 5000 "set ::Gate timed_out"]
        set listener [twapi::tls_socket -server accept -credentials $::%3$s -verifier verifytrue %2$d]
        puts ready
        vwait Gate
        after cancel $Timer
        close $listener
        puts $Received
    } $::initScript $server_port $creds_varname]
}



test tlsIO-2.1 {Validate server -verifier: success} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [basicServerScript 8828]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f x
    if {[catch {twapi::tls_socket -credentials $::clientCreds \
                    -verifier [list verify twapitestserver] \
                    127.0.0.1 8828} msg]} {
        set x [list $msg]
    } else {
        puts $msg done; flush $msg
        lappend x [gets $msg]
        close $msg
    }
    lappend x [gets $f]
    close $f
    set x
} {ready enod done}

test tlsIO-2.1.1 {Validate server -verifier: name mismatch} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [basicServerScript 8828]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f x
    if {[catch {twapi::tls_socket -credentials $::clientCreds \
                    -verifier [list verify twapitestserverx] \
                    127.0.0.1 8828} msg]} {
        set x [list $msg]
    } else {
        puts $msg enod; flush $msg
        lappend x [gets $msg]
        close $msg
    }
    lappend x [gets $f]
    close $f
    set x
} {{SSL/TLS negotiation failed. Verifier callback returned false.} EOF}

test tlsIO-2.1.2 {Validate server altname -verifier: success} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [basicServerScript 8828 altserverCreds]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f x
    if {[catch {twapi::tls_socket -credentials $::clientCreds \
                    -verifier [list verify altserver.twapitest.com] \
                    127.0.0.1 8828} msg]} {
        set x [list "client side error:$msg"]
    } else {
        puts $msg done; flush $msg
        lappend x [gets $msg]
        close $msg
    }
    lappend x [gets $f]
    close $f
    set x
} {ready enod done}

test tlsIO-2.1.3 {Validate server altname -verifier: name mismatch} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [basicServerScript 8828 altserverCreds]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f x
    if {[catch {twapi::tls_socket -credentials $::clientCreds \
                    -verifier [list verify twapitestserver.twapitest.com] \
                    127.0.0.1 8828} msg]} {
        set x [list $msg]
    } else {
        puts $msg enod; flush $msg
        lappend x [gets $msg]
        close $msg
    }
    lappend x [gets $f]
    close $f
    set x
} {{SSL/TLS negotiation failed. Verifier callback returned false.} EOF}

if [info exists Port] {
    incr Port
} else {
    set Port [expr {$tlsServerPort + [pid]%1024}]
}

test tlsIO-2.2 {Validate option -myport -myaddr: success} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [basicServerScript 8828]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f x
    if {[catch {twapi::tls_socket -credentials $::clientCreds \
                    -myport $Port -myaddr 127.0.0.2 \
                    -verifier [list verify twapitestserver] \
                    127.0.0.1 8828} msg]} {
        set x [list $msg]
    } else {
        puts $msg conninfo; flush $msg
        lappend x [gets $msg]
        close $msg
    }
    lappend x [gets $f]
    close $f
    set x
} [list ready [list [list 127.0.0.2 $Port] [list 127.0.0.1 [info hostname] 8828] [list 127.0.0.2 127.0.0.2 $Port]] conninfo]

test tlsIO-2.6 {connection to nonexistent port} {socket} {
    set status ok
    if {![catch {set sock [twapi::tls_socket 127.0.0.1 8833]}]} {
	if {![catch {gets $sock}]} {
	    set status broken
	}
	close $sock
    }
    set status
} ok

test tlsIO-2.10 {close on accept, accepted socket lives} {socket} {
    # Note for in-process tests, both sockets have to be nonblocking
    # else deadlock occurs

    set done 0
    set timer [after 20000 "set done timed_out"]
    set ss [twapi::tls_socket -server accept -credentials $serverCreds -verifier verifytrue 8830]
    proc accept {s a p} {
	global ss
	close $ss
	fileevent $s readable "readit $s"
	fconfigure $s -trans lf -blocking 0
    }
    proc readit {s} {
	global done
	gets $s
	close $s
	set done 1
    }

    # Without -async blocks, so we know -async works
    set cs [twapi::tls_socket -async -credentials $clientCreds -verifier verifytrue 127.0.0.1 8830]
    fconfigure $cs -blocking 0
    puts $cs 123 ; flush $cs
    vwait done
    close $cs
    after cancel $timer
    set done
} 1


test tlsIO-3.0 {Validate server non-blocking -verifier: success} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [asyncServerScript 8828]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f response
    if {[catch {twapi::tls_socket -credentials $::clientCreds \
                    -verifier [list verify twapitestserver] \
                    127.0.0.1 8828} msg]} {
        set response [list $msg]
    } else {
        fconfigure $msg -buffering line -translation lf
        puts $msg done; flush $msg
        lappend response [gets $msg]
        close $msg
    }
    lappend response [gets $f]
    close $f
    set response
} {ready enod {done EOF}}

test tlsIO-3.0.1 {Validate server non-blocking -verifier: success, loop} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [asyncServerScript 8828]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f;                    # Discard
    set so [twapi::tls_socket -credentials $::clientCreds \
                -verifier [list verify twapitestserver] \
                127.0.0.1 8828]
    fconfigure $so -buffering line -translation lf
    for {set i 0} {$i < 5000} {incr i} {
        puts $so $i; flush $so
        set response [gets $so]
        if {$response ne [string reverse $i]} break
    }
    puts $so quit; flush $so
    gets $so;                   # discard
    close $so
    gets $f
    close $f
    set i
} 5000

test tlsIO-3.1 {Validate server non-blocking -verifier: name mismatch} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [asyncServerScript 8828]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f x
    if {[catch {twapi::tls_socket -credentials $::clientCreds \
                    -verifier [list verify twapitestserverx] \
                    127.0.0.1 8828} msg]} {
        set x [list $msg]
    } else {
        puts $msg enod; flush $msg
        lappend x [gets $msg]
        close $msg
    }
    lappend x [gets $f]
    close $f
    set x
} {{SSL/TLS negotiation failed. Verifier callback returned false.} EOF}

incr Port
test tlsIO-3.2 {Validate server non-blocking -verifier altname: success} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [asyncServerScript 8828 altserverCreds]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f response
    if {[catch {twapi::tls_socket -credentials $::clientCreds \
                    -verifier [list verify altserver.twapitest.com] \
                    -myport $Port -myaddr 127.0.0.2 \
                    127.0.0.1 8828} msg]} {
        set response [list $msg]
    } else {
        fconfigure $msg -buffering line -translation lf
        puts $msg 123 ; puts $msg conninfo; puts $msg quit
        lappend response [gets $msg] [gets $msg]
        close $msg
    }
    lappend response [gets $f]
    close $f
    set response
} [list ready 321 [list [list 127.0.0.2 $Port] [list 127.0.0.1 [info hostname] 8828] [list 127.0.0.2 127.0.0.2 $Port]] [list 123 conninfo quit]]

test tlsIO-3.3 {Validate server -verifier: name mismatch} {socket stdio} {
    removeFile script
    set f [open script w]
    puts $f [asyncServerScript 8828]
    close $f
    set f [open "|[list $::tcltest::tcltest script]" r]
    gets $f x
    if {[catch {twapi::tls_socket -credentials $::clientCreds \
                    -verifier [list verify twapitestserverx] \
                    127.0.0.1 8828} msg]} {
        set x [list $msg]
    } else {
        puts $msg enod; flush $msg
        lappend x [gets $msg]
        close $msg
    }
    lappend x [gets $f]
    close $f
    set x
} {{SSL/TLS negotiation failed. Verifier callback returned false.} EOF}


#
# Tests against real servers
test tls_socket-client-1.0 {
    Verify basic synchronous connection
} -body {
    set so [twapi::tls_socket www.google.com 443]
    # GET / HTTP/1.0 results in EOF (server does not like request)
    # GET / HTTP/1.1 results in more complicated read as server does not close
    # so use just GET /
    puts $so "GET /"
    flush $so
    read $so
} -cleanup {
    catch {close $so}
} -result {HTTP/1.0.*<HTML>.*</HTML>\s} -match regexp

test tls_socket-client-1.1 {
    Verify basic synchronous connection with wrong name
} -body {
    list [catch {twapi::tls_socket -peersubject www.google.com www.yahoo.com 443}] [lrange $::errorCode 0 1]
} -result {1 {TWAPI_WIN32 -2146893022}}

test tls_socket-client-1.2 {
    Verify basic synchronous connection with unknown root certificate
} -body {
    list [catch {twapi::tls_socket www.mikestoolbox.org 443}] [lrange $::errorCode 0 1]
} -result {1 {TWAPI_WIN32 -2146893019}}

test tls_socket-client-1.3 {
    Verify basic synchronous connection -verifier (ok)
} -body {
    set so [twapi::tls_socket -verifier verifytrue www.google.com 443]
    # GET / HTTP/1.0 results in EOF (server does not like request)
    # GET / HTTP/1.1 results in more complicated read as server does not close
    # so use just GET /
    puts $so "GET /"
    flush $so
    read $so
} -cleanup {
    catch {close $so}
} -result {HTTP/1.0.*<HTML>.*</HTML>\s} -match regexp

test tls_socket-client-1.4 {
    Verify basic synchronous connection -verifier (fail)
} -body {
    list [catch {twapi::tls_socket -verifier verifyfalse www.yahoo.com 443} msg] $msg $::errorCode
} -result {1 {SSL/TLS negotiation failed. Verifier callback returned false.} {TWAPI TLS VERIFYFAIL}}

test tls_socket-client-1.5 {
    Verify basic synchronous connection -verifier (error)
} -body {
    list [catch {twapi::tls_socket -verifier verifyerror www.google.com 443} msg] $msg $::errorCode
} -result {1 {Verification error} {TEST TLS VERIFYFAIL}}

test tls_socket-client-1.6 {
    Verify basic synchronous connection -verifier (ok)
} -body {
    set so [twapi::tls_socket -verifier [list verify www.google.com] www.google.com 443]
    # GET / HTTP/1.0 results in EOF (server does not like request)
    # GET / HTTP/1.1 results in more complicated read as server does not close
    # so use just GET /
    puts $so "GET /"
    flush $so
    read $so
} -cleanup {
    catch {close $so}
} -result {HTTP/1.0.*<HTML>.*</HTML>\s} -match regexp

test tls_socket-client-1.7 {
    Verify basic synchronous connection -verifier (fail)
} -body {
    list [catch {twapi::tls_socket -verifier [list verify www.yahoo.com] www.google.com 443} msg] $msg $::errorCode
} -result {1 {SSL/TLS negotiation failed. Verifier callback returned false.} {TWAPI TLS VERIFYFAIL}}


test tls_socket-client-2.0 {
    Verify basic asynchronous connection
} -body {
    set so [twapi::tls_socket -async www.google.com 443]
    # GET / HTTP/1.0 results in EOF (server does not like request)
    # GET / HTTP/1.1 results in more complicated read as server does not close
    # so use just GET /
    puts $so "GET /"
    flush $so
    read $so
} -cleanup {
    catch {close $so}
} -result {HTTP/1.0.*<HTML>.*</HTML>\s} -match regexp

test tls_socket-client-2.1 {
    Verify basic asynchronous connection, wrong name (error on read)
} -body {
    set so [twapi::tls_socket -async -peersubject www.google.com  www.yahoo.com 443]
    list [catch {read $so}] [lrange $errorCode 0 1]
} -cleanup {
    catch {close $so}
} -result {1 {TWAPI_WIN32 -2146893022}}

test tls_socket-client-2.2 {
    Verify basic asynchronous connection, wrong name (error on flush)
} -body {
    set so [twapi::tls_socket -async -peersubject www.google.com  www.yahoo.com 443]
    puts $so "GET /"
    list [catch {flush $so}] [lrange $errorCode 0 1]
} -cleanup {
    catch {close $so}
} -result {1 {TWAPI_WIN32 -2146893022}}

test tls_socket-client-2.3 {
    Verify basic asynchronous connection, untrusted root (error on read)
} -body {
    set so [twapi::tls_socket -async www.mikestoolbox.org 443]
    list [catch {read $so}] [lrange $errorCode 0 1]
} -cleanup {
    catch {close $so}
} -result {1 {TWAPI_WIN32 -2146893019}}

test tls_socket-client-2.4 {
    Verify basic asynchronous connection, untrusted root (error on flush)
} -body {
    set so [twapi::tls_socket -async www.mikestoolbox.org 443]
    puts $so "GET /"
    list [catch {flush $so}] [lrange $errorCode 0 1]
} -cleanup {
    catch {close $so}
} -result {1 {TWAPI_WIN32 -2146893019}}

test tls_socket-client-2.5 {
    Verify basic asynchronous connection -verify (ok)
} -body {
    set so [twapi::tls_socket -async -verifier verifytrue www.yahoo.com 443]
    # GET / HTTP/1.0 results in EOF (server does not like request)
    # GET / HTTP/1.1 results in more complicated read as server does not close
    # so use just GET /
    puts $so "GET /"
    flush $so
    read $so
} -cleanup {
    catch {close $so}
} -result {<HEAD>.*</HEAD>\s*<BODY.*</BODY>\s} -match regexp

test tls_socket-client-2.6 {
    Verify basic asynchronous connection, -verifier (fail)
} -body {
    set so [twapi::tls_socket -async -verifier verifyfalse www.yahoo.com 443]
    list [catch {read $so} msg] $msg $::errorCode
} -cleanup {
    catch {close $so}
} -result {1 {SSL/TLS negotiation failed. Verifier callback returned false.} {TWAPI TLS VERIFYFAIL}}

test tls_socket-client-2.7 {
    Verify basic asynchronous connection, -verifier (error)
} -body {
    set so [twapi::tls_socket -async -verifier verifyerror www.yahoo.com 443]
    list [catch {puts $so "GET /" ; flush $so} msg] $msg $::errorCode
} -cleanup {
    catch {close $so}
} -result {1 {Verification error} {TEST TLS VERIFYFAIL}}


test tls_socket-client-3.0 {
    Verify event driven client i/o
} -body {
    set so [twapi::tls_socket www.yahoo.com 443]
    fconfigure $so -blocking 0 -translation binary -buffering none
    set response ""
    set reader [twapi::lambda {so} {
        append ::response [read $so]
        if {[eof $so]} {
            set ::done eof
        }
    }]
    fileevent $so readable "$reader $so"

    # GET / HTTP/1.0 results in EOF (server does not like request)
    # GET / HTTP/1.1 results in more complicated read as server does not close
    # so use just GET /
    puts $so "GET /\r\n\r\n"
    set after_id [after 5000 set ::done timeout]
    vwait ::done
    after cancel $after_id
    list $::done [regexp {<HEAD>.*</HEAD>\s*<BODY.*</BODY>\s} $response]
} -result {eof 1}

test tls_socket-client-3.1 {
    Verify event driven client i/o
} -body {
    set response ""
    set so [twapi::tls_socket -async www.google.com 443]
    fconfigure $so -blocking 0 -translation binary -buffering none
    fileevent $so writable "fileevent $so writable {}; set ::done open"
    set after_id [after 5000 set ::done timeout]
    vwait ::done
    if {$::done eq "open"} {
        # GET / HTTP/1.0 results in EOF (server does not like request)
        # GET / HTTP/1.1 results in more complicated read as server does not
        # close so use just GET /
        puts $so "GET /\r\n\r\n"
        set reader [twapi::lambda {so} {
            append ::response [read $so]
            if {[eof $so]} {
                set ::done eof
            }
        }]
        fileevent $so readable "$reader $so"
        vwait ::done
    }
    list $::done [regexp {HTTP/1.0.*<HTML>.*</HTML>\s} $response]
} -result {eof 1}

test tls_socket-client-3.2 {
    Verify event driven client i/o using gets
} -body {
    set response ""
    set so [twapi::tls_socket -async www.google.com 443]
    fconfigure $so -blocking 0 -translation lf -buffering none
    fileevent $so writable "fileevent $so writable {}; set ::done open"
    set after_id [after 5000 set ::done timeout]
    vwait ::done
    if {$::done eq "open"} {
        # GET / HTTP/1.0 results in EOF (server does not like request)
        # GET / HTTP/1.1 results in more complicated read as server does not
        # close so use just GET /
        puts $so "GET /\r\n\r\n"
        set reader [twapi::lambda {so} {
            set line [gets $so]
            puts $line
            puts EOF:[eof $so]
            append ::response ${line}\n
            if {[eof $so]} {
                set ::done eof
            }
        }]
        fileevent $so readable "$reader $so"
        vwait ::done
    }
    list $::done [regexp {HTTP/1.0.*<HTML>.*</HTML>\s} $response]
} -result {eof 1}


#
# Cleanup

twapi::sspi_free_credentials $clientCreds
twapi::sspi_free_credentials $serverCreds
twapi::cert_release $clientCert
twapi::cert_release $serverCert
twapi::cert_store_release $certStore
::tcltest::cleanupTests

