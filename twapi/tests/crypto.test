#
# Copyright (c) 2010-2013, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license

# This file contains tests for commands from crypto.tcl

package require tcltest
eval tcltest::configure $argv

source [file join [file dirname [info script]] testutil.tcl]
load_twapi_package twapi_crypto


namespace eval twapi::crypto::test {
    namespace import ::tcltest::test

    proc setup_contexts {package} {
        set ccred [twapi::sspi_acquire_credentials -direction outbound -package $package]
        set scred [twapi::sspi_acquire_credentials -direction inbound -package $package]
        set cctx [twapi::sspi_client_context $ccred -target LUNA -confidentiality true -connection true]
        lassign [twapi::sspi_step $cctx] step data extra
        set sctx [twapi::sspi_server_context $scred $data]
        lassign [twapi::sspi_step $sctx] step data extra
        lassign [twapi::sspi_step $cctx $data] step data extra
        lassign [twapi::sspi_step $sctx $data] step data extra
        twapi::sspi_free_credentials $scred
        twapi::sspi_free_credentials $ccred
        return [list $cctx $sctx]
    }

    proc encrypt_test {cctx sctx} {
        lassign [twapi::sspi_encrypt $cctx abc] sig data padding
        set data1 [twapi::sspi_decrypt $sctx $sig $data $padding]
        lassign [twapi::sspi_encrypt $cctx 123 -seqnum 1] sig data padding
        set data2 [twapi::sspi_decrypt $sctx $sig $data $padding]
        lassign [twapi::sspi_encrypt $cctx \001\002\003 -seqnum 2] sig data padding
        set data3 [twapi::sspi_decrypt $sctx $sig $data $padding]
        return [equal_lists [list $data1 $data2 $data3] [list abc 123 \001\002\003]]
    }

    proc encrypt_test_noseq {cctx sctx} {
        lassign [twapi::sspi_encrypt $cctx abc] sig data padding
        set data1 [twapi::sspi_decrypt $sctx $sig $data $padding]
        lassign [twapi::sspi_encrypt $cctx 123] sig data padding
        set data2 [twapi::sspi_decrypt $sctx $sig $data $padding]
        lassign [twapi::sspi_encrypt $cctx \001\002\003] sig data padding
        set data3 [twapi::sspi_decrypt $sctx $sig $data $padding]
        return [equal_lists [list $data1 $data2 $data3] [list abc 123 \001\002\003]]
    }

    proc sampleencodedcert {} {
        variable _sampleencodedcert
        if {![info exists _sampleencodedcert]} {
            set fd [open [file join [tcltest::testsDirectory] certs twapisamplecertfull.cer] rb]
            set _sampleencodedcert [read $fd]
            close $fd
        }
        return $_sampleencodedcert
    }

    proc temp_cert_file_store_path {} {
        variable temp_cert_file_store_path

        if {![info exists temp_cert_file_store_path]} {
            set temp_cert_file_store_path [file join [tcltest::temporaryDirectory] [clock microseconds].store]
            set hstore [twapi::cert_file_store_open $temp_cert_file_store_path -commitenable 1]
            set cer [sampleencodedcert]
            twapi::cert_release [twapi::cert_store_add_encoded_certificate $hstore $cer]
            twapi::cert_store_release $hstore
        }
        return $temp_cert_file_store_path
    }

    proc cleanup_test_cert_files {} {
        variable temp_cert_file_store_path
        if {[info exists temp_cert_file_store_path] &&
            [file exists $temp_cert_file_store_path]} {
            file delete $temp_cert_file_store_path
        }
    }

    foreach pkg {NTLM Negotiate Kerberos WDigest} {
        test encrypt-${pkg}-1.0 "Verify basic encryption and decryption - $pkg" -setup "lassign \[setup_contexts $pkg\] cctx sctx" -body {
            encrypt_test $cctx $sctx
        } -cleanup {
            twapi::sspi_delete_context $sctx
            twapi::sspi_delete_context $cctx
        } -result 1

        test encrypt-${pkg}-1.1 "Verify basic encryption and decryption without seq num - $pkg" -setup "lassign \[setup_contexts $pkg\] cctx sctx" -body {
            encrypt_test_noseq $cctx $sctx
        } -cleanup {
            twapi::sspi_delete_context $sctx
            twapi::sspi_delete_context $cctx
        } -result 1
    }

    test sign-1.0 {
        Verify basic signing and verification
    } -setup {
        foreach {cctx sctx} [setup_contexts NTLM] break
    } -body {
        foreach {sig data} [twapi::sspi_sign $cctx abcd] break
        set flags1 [twapi::sspi_verify_signature $sctx $sig $data]
        foreach {sig data} [twapi::sspi_sign $cctx 1234] break
        set flags2 [twapi::sspi_verify_signature $sctx $sig $data]
        list [string is integer -strict $flags1] [string is integer -strict $flags2]
    } -cleanup {
        twapi::sspi_delete_context $sctx
        twapi::sspi_delete_context $cctx
    } -result [list 1 1]
        
    test sspi_enumerate_packages-1.0 {
        Enumerate SSPI providers
    } -body {
        set packages [twapi::sspi_enumerate_packages]
        expr {
              [lsearch -exact $packages NTLM] >= 0 &&
              [lsearch -exact $packages Kerberos] >= 0 &&
              [lsearch -exact $packages Schannel] >= 0 &&
              [lsearch -exact $packages Negotiate] >= 0
          }
    } -result 1

    test sspi_enumerate_packages-2.0 {
        Enumerate SSPI providers -all
    } -body {
        set packages [twapi::sspi_enumerate_packages -all]
        set missing {}
        foreach pkgname {NTLM Kerberos Schannel Negotiate} {
            foreach field {-capabilities -version -rpcid -name -maxtokensize -comment} {
                if {![dict exists $packages $pkgname $field]} {
                    lappend missing $pkgname.$field
                }
            }
        }
        set missing
    } -result {}

    test sspi_enumerate_packages-2.1 {
        Enumerate SSPI providers -all extra args
    } -body {
        set packages [twapi::sspi_enumerate_packages -all somearg]
    } -returnCodes error -result "Command has extra arguments specified: somearg"

    test sspi_enumerate_packages-3.0 {
        Enumerate SSPI providers -capabilities
    } -body {
        set packages [twapi::sspi_enumerate_packages -capabilities]
        set errors {}
        # Just some random sanity checks
        foreach {name cap} {
            Schannel stream
            Schannel mutualauth
            Negotiate connection
            Negotiate gsscompatible
            NTLM multirequired
            Kerberos datagram
        } {
            if {[lsearch -exact [dict get $packages $name -capabilities] $cap] < 0} {
                lappend errors "Capability $cap missing in $name"
            }
        }
        foreach {name cap} {
            Schannel logon
            Schannel datagram
            Negotiate stream
            Negotiate mutualauth
            NTLM gsscompatible
            NTLM datagram
            NTLM stream
            Kerberos stream
        } {
            if {[lsearch -exact [dict get $packages $name -capabilities] $cap] >= 0} {
                lappend errors "Capability $cap should not be present in $name"
            }
        }

        set errors
    } -result {}

    test sspi_enumerate_packages-4.0 {
        Enumerate SSPI providers -version
    } -body {
        set packages [twapi::sspi_enumerate_packages -version]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                if {[dict get $pkg -version] != 1} {
                    lappend errors "$pkgname version is not 1"
                }
            }
        }
        set errors
    } -result {}

    test sspi_enumerate_packages-5.0 {
        Enumerate SSPI providers -rpcid
    } -body {
        set packages [twapi::sspi_enumerate_packages -rpcid]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                if {![string is integer -strict [dict get $pkg -rpcid]]} {
                    lappend errors "$pkgname rpcid is not an integer"
                }
            }
        }
        set errors
    } -result {}

    test sspi_enumerate_packages-6.0 {
        Enumerate SSPI providers -maxtokensize
    } -body {
        set packages [twapi::sspi_enumerate_packages -maxtokensize]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                if {![string is integer -strict [dict get $pkg -maxtokensize]]} {
                    lappend errors "$pkgname maxtokensize is not an integer"
                }
                if {[dict get $pkg -maxtokensize] < 0} {
                    lappend errors "$pkgname maxtokensize is less than 0"
                }
            }
        }
        set errors
    } -result {}

    test sspi_enumerate_packages-7.0 {
        Enumerate SSPI providers -name
    } -body {
        set packages [twapi::sspi_enumerate_packages -name]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                if {$pkgname ne [dict get $pkg -name]} {
                    lappend errors "$pkgname name does not match"
                }
            }
        }
        set errors
    } -result {}

    test sspi_enumerate_packages-8.0 {
        Enumerate SSPI providers -comment
    } -body {
        set packages [twapi::sspi_enumerate_packages -comment]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                # Nothing to check except that the field exists
                dict get $pkg -comment
            }
        }
        set errors
    } -result {}


    # Certificate Stores

    test cert_store_release {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_memory_store_open-1.0 {
        Open a memory store
    } -body {
        twapi::cert_store_release [twapi::cert_memory_store_open]
    } -result 1

    test cert_memory_store_open-1.1 {
        Open a memory store and add a certificate to it
    } -body {
        set hstore [twapi::cert_memory_store_open]
        set cer [sampleencodedcert]
        twapi::cert_release [twapi::cert_store_add_encoded_certificate $hstore $cer]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_memory_store_open-2.0 {
        Verify cert memory stores protected against double frees
    } -body {
        set store [twapi::cert_memory_store_open]
        twapi::cert_store_release $store
        twapi::cert_store_release $store
    } -result "*Pointer is not registered*" -returnCodes error -match glob

    test cert_file_store_open-1.0 {
        Open a non-existing file store
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        list [catch {twapi::cert_file_store_open $storepath} msg] [lrange $::errorCode 0 1]
    } -result {1 {TWAPI_WIN32 2}}

    test cert_file_store_open-1.1 {
        Open a non-existing file store -readonly
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        list [catch {twapi::cert_file_store_open $storepath -readonly 1} msg] [lrange $::errorCode 0 1]
    } -result {1 {TWAPI_WIN32 2}}

    test cert_file_store_open-1.2 {
        Open a non-existing file store -readonly 1 -commitenable 1
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        twapi::cert_file_store_open $storepath -readonly 1 -commitenable 1
    } -result {Options -commitenable and -readonly are mutually exclusive.} -returnCodes error

    test cert_file_store_open-1.3 {
        Open a non-existing file store -commitenable 1
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -commitenable 1]
        set cer [sampleencodedcert]
        twapi::cert_release [twapi::cert_store_add_encoded_certificate $hstore $cer]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_file_store_open-1.4 {
        Open a non-existing file store -commitenable 1 -readonly 0
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -commitenable 1]
        set cer [sampleencodedcert]
        twapi::cert_release [twapi::cert_store_add_encoded_certificate $hstore $cer]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_file_store_open-1.5 {
        Open a non-existing file store -commitenable 1 -existing 1
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        list [catch {twapi::cert_file_store_open $storepath -commitenable 1 -existing 1}] [lrange $::errorCode 0 1]
    } -result {1 {TWAPI_WIN32 2}}

    test cert_file_store_open-2.0 {
        Open an existing file store
    } -setup {
        set storepath [temp_cert_file_store_path]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_file_store_open-2.1 {
        Open an existing file store -readonly 1
    } -setup {
        set storepath [temp_cert_file_store_path]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -readonly 1]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_file_store_open-2.2 {
        Open an existing file store -create 0
    } -setup {
        set storepath [temp_cert_file_store_path]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -create 0]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_file_store_open-2.3 {
        Open an existing file store -create 1
    } -setup {
        set storepath [temp_cert_file_store_path]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -create 1]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert


    test cert_file_store_open {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD
    test cert_file_store_open {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_physical_store_open {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_physical_store_delete {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_system_store_open {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_system_store_delete {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    set i -1
    foreach loc [concat {user users service services localmachine localmachineenterprise localmachinegrouppolicy usergrouppolicy} [twapi::cert_system_store_locations]] {
        test "cert_system_stores-$loc-1.0" {
            Get system store list
        } -body [format {
            set stores [twapi::cert_system_stores %s]
            expr {"My" in $stores && "CA" in $stores && "Root" in $stores}
        } $loc] -result 1
    }

    test cert_system_store_locations-1.0 {
        Get system store locations
    } -body {
        set locs [twapi::cert_system_store_locations]
        expr {
              "CurrentUser" in $locs &&
              "LocalMachine" in $locs &&
              "Service" in $locs
          }
    } -result 1

    test cert_store_find_certificate {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD


    test cert_store_enum_contents {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_add_certificate {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_add_encoded_certificate {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_to_pfx {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_to_pkcs12 {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_to_pkcs7 {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_to_serialize {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_commit {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_subject_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_issuer_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_blob_to_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_name_to_blob {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_enum_properties {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_property {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_set_key_prov {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_export {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_enhkey_usage {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_key_usage {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_thumbprint {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_info {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_extension {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_create_self_signed {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_create_self_signed_from_crypt_context {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_create {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_request {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD
    
    test cert_tls_verify {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_locate_private_key {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_acquire {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_free {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_container_delete {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_generate {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_keypair {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_public_key {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_get_security_descriptor {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_set_security_descriptor {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_container_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_container_unique_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_csp {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_csptype {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_container_names {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_session_key_size {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_keyset_type {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_symmetric_key_size {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD
}

twapi::crypto::test::cleanup_test_cert_files
::tcltest::cleanupTests
namespace delete ::twapi::crypto::test
