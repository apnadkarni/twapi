#
# Copyright (c) 2010-2013, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license

# This file contains tests for commands from crypto.tcl

package require tcltest
eval tcltest::configure $argv

source [file join [file dirname [info script]] testutil.tcl]
load_twapi_package twapi_crypto


namespace eval twapi::crypto::test {
    namespace import ::tcltest::test

    proc setup_contexts {package} {
        set ccred [twapi::sspi_acquire_credentials -role client -package $package]
        set scred [twapi::sspi_acquire_credentials -role server -package $package]
        set cctx [twapi::sspi_client_context $ccred -target LUNA -confidentiality true -connection true]
        lassign [twapi::sspi_step $cctx] step data extra
        set sctx [twapi::sspi_server_context $scred $data]
        lassign [twapi::sspi_step $sctx] step data extra
        lassign [twapi::sspi_step $cctx $data] step data extra
        lassign [twapi::sspi_step $sctx $data] step data extra
        twapi::sspi_free_credentials $scred
        twapi::sspi_free_credentials $ccred
        return [list $cctx $sctx]
    }

    proc encrypt_test {cctx sctx} {
        lassign [twapi::sspi_encrypt $cctx abc] sig data padding
        set data1 [twapi::sspi_decrypt $sctx $sig $data $padding]
        lassign [twapi::sspi_encrypt $cctx 123 -seqnum 1] sig data padding
        set data2 [twapi::sspi_decrypt $sctx $sig $data $padding]
        lassign [twapi::sspi_encrypt $cctx \001\002\003 -seqnum 2] sig data padding
        set data3 [twapi::sspi_decrypt $sctx $sig $data $padding]
        return [equal_lists [list $data1 $data2 $data3] [list abc 123 \001\002\003]]
    }

    proc encrypt_test_noseq {cctx sctx} {
        lassign [twapi::sspi_encrypt $cctx abc] sig data padding
        set data1 [twapi::sspi_decrypt $sctx $sig $data $padding]
        lassign [twapi::sspi_encrypt $cctx 123] sig data padding
        set data2 [twapi::sspi_decrypt $sctx $sig $data $padding]
        lassign [twapi::sspi_encrypt $cctx \001\002\003] sig data padding
        set data3 [twapi::sspi_decrypt $sctx $sig $data $padding]
        return [equal_lists [list $data1 $data2 $data3] [list abc 123 \001\002\003]]
    }

    proc sampleencodedcert {} {
        variable _sampleencodedcert
        if {![info exists _sampleencodedcert]} {
            set fd [open [file join [tcltest::testsDirectory] certs twapisamplecertfull.cer] rb]
            set _sampleencodedcert [read $fd]
            close $fd
        }
        return $_sampleencodedcert
    }

    proc temp_cert_file_store_path {} {
        variable temp_cert_file_store_path

        if {![info exists temp_cert_file_store_path]} {
            set temp_cert_file_store_path [file join [tcltest::temporaryDirectory] [clock microseconds].store]
            set hstore [twapi::cert_file_store_open $temp_cert_file_store_path -commitenable 1]
            set cer [sampleencodedcert]
            twapi::cert_release [twapi::cert_store_add_encoded_certificate $hstore $cer]
            twapi::cert_store_release $hstore
        }
        return $temp_cert_file_store_path
    }

    proc cleanup_test_cert_files {} {
        variable temp_cert_file_store_path
        if {[info exists temp_cert_file_store_path] &&
            [file exists $temp_cert_file_store_path]} {
            file delete $temp_cert_file_store_path
        }
    }

    proc equal_certs {certa certb} {
        return [expr {[twapi::cert_thumbprint $certa] eq [twapi::cert_thumbprint $certb]}]
    }

    # Returns cert from a store at index n for testing searches
    # Errors if not enough certs
    proc pick_cert {hstore {n 4}} {
        set hcert NULL
        time {set hcert [twapi::cert_store_find_certificate $hstore any "" $hcert]} [incr n]
        return $hcert
    }

    foreach pkg {NTLM Negotiate Kerberos} {
        test encrypt-${pkg}-1.0 "Verify basic encryption and decryption - $pkg" -setup "lassign \[setup_contexts $pkg\] cctx sctx" -constraints [expr {$pkg eq "Kerberos" ? "domain" : ""}]  -body {
            encrypt_test $cctx $sctx
        } -cleanup {
            twapi::sspi_delete_context $sctx
            twapi::sspi_delete_context $cctx
        } -result 1

        test encrypt-${pkg}-1.1 "Verify basic encryption and decryption without seq num - $pkg" -setup "lassign \[setup_contexts $pkg\] cctx sctx" -constraints [expr {$pkg eq "Kerberos" ? "domain" : ""}] -body {
            encrypt_test_noseq $cctx $sctx
        } -cleanup {
            twapi::sspi_delete_context $sctx
            twapi::sspi_delete_context $cctx
        } -result 1
    }

    test encrypt-WDigest-1.0 {
        TBD - Verify basic encryption and decryption - WDigest
    } -constraints {
        TBD
    } -body {
        TBD - add to loop above once WDigest is supported
    } -result TBD

    test sign-1.0 {
        Verify basic signing and verification
    } -setup {
        foreach {cctx sctx} [setup_contexts NTLM] break
    } -body {
        foreach {sig data} [twapi::sspi_sign $cctx abcd] break
        set flags1 [twapi::sspi_verify_signature $sctx $sig $data]
        foreach {sig data} [twapi::sspi_sign $cctx 1234] break
        set flags2 [twapi::sspi_verify_signature $sctx $sig $data]
        list [string is integer -strict $flags1] [string is integer -strict $flags2]
    } -cleanup {
        twapi::sspi_delete_context $sctx
        twapi::sspi_delete_context $cctx
    } -result [list 1 1]
        
    test sspi_enumerate_packages-1.0 {
        Enumerate SSPI providers
    } -body {
        set packages [twapi::sspi_enumerate_packages]
        expr {
              [lsearch -exact $packages NTLM] >= 0 &&
              [lsearch -exact $packages Kerberos] >= 0 &&
              [lsearch -exact $packages Schannel] >= 0 &&
              [lsearch -exact $packages Negotiate] >= 0
          }
    } -result 1

    test sspi_enumerate_packages-2.0 {
        Enumerate SSPI providers -all
    } -body {
        set packages [twapi::sspi_enumerate_packages -all]
        set missing {}
        foreach pkgname {NTLM Kerberos Schannel Negotiate} {
            foreach field {-capabilities -version -rpcid -name -maxtokensize -comment} {
                if {![dict exists $packages $pkgname $field]} {
                    lappend missing $pkgname.$field
                }
            }
        }
        set missing
    } -result {}

    test sspi_enumerate_packages-2.1 {
        Enumerate SSPI providers -all extra args
    } -body {
        set packages [twapi::sspi_enumerate_packages -all somearg]
    } -returnCodes error -result "Command has extra arguments specified: somearg"

    test sspi_enumerate_packages-3.0 {
        Enumerate SSPI providers -capabilities
    } -body {
        set packages [twapi::sspi_enumerate_packages -capabilities]
        set errors {}
        # Just some random sanity checks
        foreach {name cap} {
            Schannel stream
            Schannel mutualauth
            Negotiate connection
            Negotiate gsscompatible
            NTLM multirequired
            Kerberos datagram
        } {
            if {[lsearch -exact [dict get $packages $name -capabilities] $cap] < 0} {
                lappend errors "Capability $cap missing in $name"
            }
        }
        foreach {name cap} {
            Schannel logon
            Schannel datagram
            Negotiate stream
            Negotiate mutualauth
            NTLM gsscompatible
            NTLM datagram
            NTLM stream
            Kerberos stream
        } {
            if {[lsearch -exact [dict get $packages $name -capabilities] $cap] >= 0} {
                lappend errors "Capability $cap should not be present in $name"
            }
        }

        set errors
    } -result {}

    test sspi_enumerate_packages-4.0 {
        Enumerate SSPI providers -version
    } -body {
        set packages [twapi::sspi_enumerate_packages -version]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                if {[dict get $pkg -version] != 1} {
                    lappend errors "$pkgname version is not 1"
                }
            }
        }
        set errors
    } -result {}

    test sspi_enumerate_packages-5.0 {
        Enumerate SSPI providers -rpcid
    } -body {
        set packages [twapi::sspi_enumerate_packages -rpcid]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                if {![string is integer -strict [dict get $pkg -rpcid]]} {
                    lappend errors "$pkgname rpcid is not an integer"
                }
            }
        }
        set errors
    } -result {}

    test sspi_enumerate_packages-6.0 {
        Enumerate SSPI providers -maxtokensize
    } -body {
        set packages [twapi::sspi_enumerate_packages -maxtokensize]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                if {![string is integer -strict [dict get $pkg -maxtokensize]]} {
                    lappend errors "$pkgname maxtokensize is not an integer"
                }
                if {[dict get $pkg -maxtokensize] < 0} {
                    lappend errors "$pkgname maxtokensize is less than 0"
                }
            }
        }
        set errors
    } -result {}

    test sspi_enumerate_packages-7.0 {
        Enumerate SSPI providers -name
    } -body {
        set packages [twapi::sspi_enumerate_packages -name]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                if {$pkgname ne [dict get $pkg -name]} {
                    lappend errors "$pkgname name does not match"
                }
            }
        }
        set errors
    } -result {}

    test sspi_enumerate_packages-8.0 {
        Enumerate SSPI providers -comment
    } -body {
        set packages [twapi::sspi_enumerate_packages -comment]
        set errors {}
        if {[dict size $packages] == 0} {
            lappend errors "No security packages listed"
        } else {
            dict for {pkgname pkg} $packages {
                # Nothing to check except that the field exists
                dict get $pkg -comment
            }
        }
        set errors
    } -result {}


    # Certificate Stores

    test cert_store_release {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_memory_store_open-1.0 {
        Open a memory store
    } -body {
        twapi::cert_store_release [twapi::cert_memory_store_open]
    } -result 1

    test cert_memory_store_open-1.1 {
        Open a memory store and add a certificate to it
    } -body {
        set hstore [twapi::cert_memory_store_open]
        set cer [sampleencodedcert]
        twapi::cert_release [twapi::cert_store_add_encoded_certificate $hstore $cer]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_memory_store_open-2.0 {
        Verify cert memory stores protected against double frees
    } -body {
        set store [twapi::cert_memory_store_open]
        twapi::cert_store_release $store
        twapi::cert_store_release $store
    } -result "*Pointer is not registered*" -returnCodes error -match glob

    test cert_file_store_open-1.0 {
        Open a non-existing file store
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        list [catch {twapi::cert_file_store_open $storepath} msg] [lrange $::errorCode 0 1]
    } -result {1 {TWAPI_WIN32 2}}

    test cert_file_store_open-1.1 {
        Open a non-existing file store -readonly
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        list [catch {twapi::cert_file_store_open $storepath -readonly 1} msg] [lrange $::errorCode 0 1]
    } -result {1 {TWAPI_WIN32 2}}

    test cert_file_store_open-1.2 {
        Open a non-existing file store -readonly 1 -commitenable 1
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        twapi::cert_file_store_open $storepath -readonly 1 -commitenable 1
    } -result {Options -commitenable and -readonly are mutually exclusive.} -returnCodes error

    test cert_file_store_open-1.3 {
        Open a non-existing file store -commitenable 1
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -commitenable 1]
        set cer [sampleencodedcert]
        twapi::cert_release [twapi::cert_store_add_encoded_certificate $hstore $cer]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
        file delete $storepath
    } -result twapisamplecert

    test cert_file_store_open-1.4 {
        Open a non-existing file store -commitenable 1 -readonly 0
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -commitenable 1]
        set cer [sampleencodedcert]
        twapi::cert_release [twapi::cert_store_add_encoded_certificate $hstore $cer]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
        file delete $storepath
    } -result twapisamplecert

    test cert_file_store_open-1.5 {
        Open a non-existing file store -commitenable 1 -existing 1
    } -setup {
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
    } -body {
        list [catch {twapi::cert_file_store_open $storepath -commitenable 1 -existing 1}] [lrange $::errorCode 0 1]
    } -result {1 {TWAPI_WIN32 2}}

    test cert_file_store_open-2.0 {
        Open an existing file store
    } -setup {
        set storepath [temp_cert_file_store_path]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_file_store_open-2.1 {
        Open an existing file store -readonly 1
    } -setup {
        set storepath [temp_cert_file_store_path]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -readonly 1]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_file_store_open-2.2 {
        Open an existing file store -create 0
    } -setup {
        set storepath [temp_cert_file_store_path]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -create 0]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_file_store_open-2.3 {
        Open an existing file store -create 1
    } -setup {
        set storepath [temp_cert_file_store_path]
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -create 1]
        set hcert [twapi::cert_store_enum_contents $hstore]
        twapi::cert_subject_name $hcert
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -result twapisamplecert

    test cert_file_store_open-3.0 {
        Verify changes to cert contexts persisted after store closed -deferclose 1
    } -setup {
        # Create temporary store to modify
        set storepath [file join [tcltest::temporaryDirectory] [clock microseconds].store]
        set hstore [twapi::cert_file_store_open $storepath -commitenable 1]
        set cer [sampleencodedcert]
        set hcert [twapi::cert_store_add_encoded_certificate $hstore $cer]
        twapi::cert_property_set $hcert description "original"
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
    } -body {
        set hstore [twapi::cert_file_store_open $storepath -commitenable 1]
        set hcert [twapi::cert_store_enum_contents $hstore]
        set desc1 [twapi::cert_property $hcert description]
        twapi::cert_store_release $hstore; # Close store first
        twapi::cert_property_set $hcert description "new"; # Should NOT be saved
        twapi::cert_release $hcert

        set hstore [twapi::cert_file_store_open $storepath -commitenable 1 -deferclose 1]
        set hcert [twapi::cert_store_enum_contents $hstore]
        set desc2 [twapi::cert_property $hcert description]
        twapi::cert_store_release $hstore; # Close store first
        twapi::cert_property_set $hcert description "new"; # SHOULD be saved
        twapi::cert_release $hcert

        set hstore [twapi::cert_file_store_open $storepath -commitenable 1]
        set hcert [twapi::cert_store_enum_contents $hstore]
        set desc3 [twapi::cert_property $hcert description]

        list $desc1 $desc2 $desc3
    } -cleanup {
        twapi::cert_release $hcert
        twapi::cert_store_release $hstore
        file delete $storepath
    } -result [list original original new]

    test cert_file_store_open-4.0 {
        TBD - cert_file_store_open -backupprivilege
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_file_store_open-5.0 {
        TBD - cert_file_store_open -includearchived
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_file_store_open-6.0 {
        TBD - cert_file_store_open -maxpermissions
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_physical_store_open {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_physical_store_delete {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_system_store_open {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_system_store_delete {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    set i -1
    foreach loc [concat {user users service services localmachine localmachineenterprise localmachinegrouppolicy usergrouppolicy} [twapi::cert_system_store_locations]] {
        test "cert_system_stores-$loc-1.0" {
            Get system store list
        } -body [format {
            set stores [twapi::cert_system_stores %s]
            expr {"My" in $stores && "CA" in $stores && "Root" in $stores}
        } $loc] -result 1
    }

    test cert_system_store_locations-1.0 {
        Get system store locations
    } -body {
        set locs [twapi::cert_system_store_locations]
        expr {
              "CurrentUser" in $locs &&
              "LocalMachine" in $locs &&
              "Service" in $locs
          }
    } -result 1

    test cert_store_find_certificate-1.0 {
        Find certificate any, system store
    } -setup {
        set hstore [twapi::cert_system_store_open CA]
    } -body {
        set hcert NULL
        set count 0
        while {1} {
            set hcert2 [twapi::cert_store_find_certificate $hstore any "" $hcert]
            if {[llength $hcert2] == 0} break; # Iteration over
            incr count
            # Verify it is a cert
            twapi::cert_subject_name $hcert2
            # Verify previous cert was released
            if {$hcert ne "NULL"} {
                if {! [catch {twapi::cert_release $hcert}]} {
                    error "Previous cert was not released"
                }
            }
            set hcert $hcert2
        }
        expr {$count > 10}
    } -cleanup {
        twapi::cert_store_release $hstore
    } -result 1

    test cert_store_find_certificate-1.1 {
        Find certificate any - single cert, file store
    } -setup {
        set hstore [twapi::cert_file_store_open [temp_cert_file_store_path]]
    } -body {
        set hcert NULL
        set count 0
        while {1} {
            set hcert2 [twapi::cert_store_find_certificate $hstore any "" $hcert]
            if {[llength $hcert2] == 0} break; # Iteration over
            incr count
            # Verify it is a cert
            set subj [twapi::cert_subject_name $hcert2]
            # Verify previous cert was released
            if {$hcert ne "NULL"} {
                if {! [catch {twapi::cert_release $hcert}]} {
                    error "Previous cert was not released"
                }
            }
            set hcert $hcert2
        }
        list $subj $count
    } -cleanup {
        twapi::cert_store_release $hstore
    } -result {twapisamplecert 1}

    test cert_store_find_certificate-1.2 {
        Find certificate any - no cert, memory store
    } -setup {
        set hstore [twapi::cert_memory_store_open]
    } -body {
        twapi::cert_store_find_certificate $hstore any ""
    } -cleanup {
        twapi::cert_store_release $hstore
    } -result {}

    test cert_store_find_certificate-2.0 {
        Find certificate -existing
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
    } -body {
        # Assumes exactly one cert with that pub key
        set cert2 [twapi::cert_store_find_certificate $hstore existing $cert]
        equal_certs $cert $cert2
    } -cleanup {
        twapi::cert_store_release $hstore
        twapi::cert_release $cert
        twapi::cert_release $cert2
    } -result 1

    test cert_store_find_certificate-2.1 {
        Find certificate - existing (fail)
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore 0]
        set hstore2 [twapi::cert_file_store_open [temp_cert_file_store_path]]
    } -body {
        twapi::cert_store_find_certificate $hstore2 existing $cert
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
        twapi::cert_store_release $hstore2
    } -result ""

    test cert_store_find_certificate-3.0 {
        Find certificate - issuer_name
    } -setup {
        # Choose CA (Intermediate Auth) so issuer not same as subject
        set hstore [twapi::cert_system_store_open CA]
        set cert [pick_cert $hstore]
        set issuer_name [twapi::cert_issuer_name $cert -name rdn]
    } -body {
        # Assumes exactly one cert with that pub key
        set cert2 [twapi::cert_store_find_certificate $hstore issuer_name [twapi::cert_name_to_blob $issuer_name]]
        string equal $issuer_name [twapi::cert_issuer_name $cert2 -name rdn]
    } -cleanup {
        twapi::cert_store_release $hstore
        twapi::cert_release $cert
        twapi::cert_release $cert2
    } -result 1

    test cert_store_find_certificate-3.1 {
        Find certificate - issuer_name (fail)
    } -setup {
        set hstore [twapi::cert_system_store_open CA]
        set cert [pick_cert $hstore 0]
        set hstore2 [twapi::cert_file_store_open [temp_cert_file_store_path]]
        set issuer_name [twapi::cert_issuer_name $cert -name rdn]
    } -body {
        twapi::cert_store_find_certificate $hstore2 issuer_name [twapi::cert_name_to_blob $issuer_name]
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
        twapi::cert_store_release $hstore2
    } -result ""

    test cert_store_find_certificate-3.2 {
        Find certificate - issuer_name (multiple)
    } -setup {
        # Choose CA (Intermediate Auth) so issuer not same as subject
        set hstore [twapi::cert_system_store_open CA]
        # Try to find a issuer with more than one cert
        if {$::tcl_platform(osVersion) eq "5.1"} {
            set issuer_name {OU=Copyright (c) 1997 Microsoft Corp., OU=Microsoft Corporation, CN=Microsoft Root Authority}
        } else {
            set issuer_name {C=US, O="VeriSign, Inc.", OU=VeriSign Trust Network, OU="(c) 2006 VeriSign, Inc. - For authorized use only", CN=VeriSign Class 3 Public Primary Certification Authority - G5}
        }
        set issuer_blob [twapi::cert_name_to_blob $issuer_name]
    } -body {
        set count 0
        set matches 0
        set cert NULL
        while {1} {
            set cert [twapi::cert_store_find_certificate $hstore issuer_name $issuer_blob $cert]
            if {$cert eq ""} break
            incr count
            incr matches [string equal $issuer_name [twapi::cert_issuer_name $cert -name rdn]]
        }
        list [expr {$count > 0}] [expr {$count == $matches}]
    } -cleanup {
        twapi::cert_store_release $hstore
    } -result {1 1}


    test cert_store_find_certificate-4.0 {
        Find certificate - issuer_substring
    } -setup {
        # Choose CA (Intermediate Auth) so issuer not same as subject
        set hstore [twapi::cert_system_store_open CA]
    } -body {
        set cert [twapi::cert_store_find_certificate $hstore issuer_substring microsoft]
        string match -nocase *microsoft* [twapi::cert_issuer_name $cert -name rdn -format simple]
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
    } -result 1

    test cert_store_find_certificate-4.1 {
        Find certificate - issuer_substring (fail)
    } -setup {
        # Choose CA (Intermediate Auth) so issuer not same as subject
        set hstore [twapi::cert_system_store_open CA]
    } -body {
        twapi::cert_store_find_certificate $hstore issuer_substring XmicrosoftX
    } -cleanup {
        twapi::cert_store_release $hstore
    } -result ""

    test cert_store_find_certificate-4.2 {
        Find certificate - issuer_substring (multiple)
    } -setup {
        # Choose CA (Intermediate Auth) so issuer not same as subject
        set hstore [twapi::cert_system_store_open CA]
    } -body {
        set count 0
        set matches 0
        set cert NULL
        while {1} {
            set cert [twapi::cert_store_find_certificate $hstore issuer_substring microsoft $cert]
            if {$cert eq ""} break
            incr count
            incr matches [string match -nocase *microsoft* [twapi::cert_issuer_name $cert -name rdn]]
        }
        list [expr {$count > 1}] [expr {$count == $matches}]
    } -cleanup {
        twapi::cert_store_release $hstore
    } -result {1 1}

    test cert_store_find_certificate-5.0 {
        Find certificate - key_identifier
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
        set ki [twapi::cert_property $cert key_identifier]
    } -body {
        # Assumes exactly one cert with that pub key
        set cert2 [twapi::cert_store_find_certificate $hstore key_identifier $ki]
        list [equal_certs $cert $cert2] [string equal $ki [twapi::cert_property $cert2 key_identifier]]
    } -cleanup {
        twapi::cert_store_release $hstore
        twapi::cert_release $cert2
        twapi::cert_release $cert
    } -result {1 1}

    test cert_store_find_certificate-6.0 {
        Find certificate - md5_hash
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
        set hash [twapi::cert_property $cert md5_hash]
    } -body {
        set cert2 [twapi::cert_store_find_certificate $hstore md5_hash $hash]
        set hash2 [twapi::cert_property $cert2 md5_hash]; # since cert2 will be freed 
        set cert3 [twapi::cert_store_find_certificate $hstore md5_hash $hash $cert2]; # Frees cert2
        list [string equal $hash $hash2] $cert3
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
    } -result {1 {}}

    test cert_store_find_certificate-6.1 {
        Find certificate - md5_hash (fail)
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
        set hash [twapi::cert_property $cert md5_hash]
        set hash "[string range $hash 0 end-1]\0"
    } -body {
        twapi::cert_store_find_certificate $hstore md5_hash $hash
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
    } -result {}

    foreach prop {access_state archived auto_enroll date_stamp description enhkey_usage extended_error_info friendly_name issuer_public_key_md5_hash issuer_serial_number_md5_hash key_context key_identifier key_prov_handle key_prov_info key_spec md5_hash pvk_file sha1_hash signature_hash subject_name_md5_hash subject_public_key_md5_hash} {
        test cert_store_find_certificate-${prop}-7.0 "Find certificate - property $prop" -setup {
            set hstore [twapi::cert_system_store_open CA]
        } -body [format {
            set cert [twapi::cert_store_find_certificate $hstore property %1$s]
            if {$cert ne ""} {
                # Ensure we can get the property with no errors
                twapi::cert_property $cert %1$s
                twapi::cert_release $cert
            }
        } $prop] -cleanup {
            twapi::cert_store_release $hstore
        } -result {}

        test cert_store_find_certificate-${prop}-7.1 "Find certificate - numeric property [twapi::_cert_prop_id $prop]" -setup {
            set hstore [twapi::cert_system_store_open CA]
        } -body [format {
            set cert [twapi::cert_store_find_certificate $hstore property %1$s]
            if {$cert ne ""} {
                # Ensure we can get the property with no errors
                twapi::cert_property $cert %1$s
                twapi::cert_release $cert
            }
        } [twapi::_cert_prop_id $prop]] -cleanup {
            twapi::cert_store_release $hstore
        } -result {}

    }

    test cert_store_find_certificate-7.x {
        TBD - Need better tests for property - above tests just check no errors generated
    } -constraints {
        TBD
    } -setup {
    } -body {
    } -result TBD

    test cert_store_find_certificate-8.0 {
        Find certificate - public_key_md5_hash
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
        set hash [twapi::cert_property $cert public_key_md5_hash]
    } -body {
        set cert2 [twapi::cert_store_find_certificate $hstore public_key_md5_hash $hash]
        set hash2 [twapi::cert_property $cert2 public_key_md5_hash]; # since cert2 will be freed 
        set cert3 [twapi::cert_store_find_certificate $hstore public_key_md5_hash $hash $cert2]; # Frees cert2
        list [string equal $hash $hash2] $cert3
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
    } -result {1 {}}

    test cert_store_find_certificate-10.0 {
        Find certificate -public_key
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
        set pubkey [dict get [twapi::cert_info $cert] -publickey]
    } -body {
        # Assumes exactly one cert with that pub key
        set cert2 [twapi::cert_store_find_certificate $hstore public_key $pubkey]
        equal_certs $cert $cert2
    } -cleanup {
        twapi::cert_store_release $hstore
        twapi::cert_release $cert
        twapi::cert_release $cert2
    } -result 1

    test cert_store_find_certificate-11.0 {
        Find certificate - sha1_hash
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
        set hash [twapi::cert_property $cert sha1_hash]
    } -body {
        set cert2 [twapi::cert_store_find_certificate $hstore sha1_hash $hash]
        set hash2 [twapi::cert_property $cert2 sha1_hash]; # since cert2 will be freed 
        set cert3 [twapi::cert_store_find_certificate $hstore sha1_hash $hash $cert2]; # Frees cert2
        list [string equal $hash $hash2] $cert3
    } -cleanup {
        twapi::cert_store_release $hstore
        twapi::cert_release $cert
    } -result {1 {}}

    test cert_store_find_certificate-11.1 {
        Find certificate - sha1_hash (fail)
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
        set hash [twapi::cert_property $cert sha1_hash]
        set hash "[string range $hash 0 end-1]\0"
    } -body {
        twapi::cert_store_find_certificate $hstore sha1_hash $hash
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
    } -result {}

    test cert_store_find_certificate-12.0 {
        Find certificate - signature_hash
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
        set hash [twapi::cert_property $cert signature_hash]
    } -body {
        set cert2 [twapi::cert_store_find_certificate $hstore signature_hash $hash]
        set hash2 [twapi::cert_property $cert2 signature_hash]; # since cert2 will be freed 
        set cert3 [twapi::cert_store_find_certificate $hstore signature_hash $hash $cert2]; # Frees cert2
        list [string equal $hash $hash2] $cert3
    } -cleanup {
        twapi::cert_store_release $hstore
        twapi::cert_release $cert
    } -result {1 {}}

    test cert_store_find_certificate-12.1 {
        Find certificate - signature_hash (fail)
    } -setup {
        set hstore [twapi::cert_system_store_open Root]
        set cert [pick_cert $hstore]
        set hash [twapi::cert_property $cert signature_hash]
        set hash "[string range $hash 0 end-1]\0"
    } -body {
        twapi::cert_store_find_certificate $hstore signature_hash $hash
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
    } -result {}

    test cert_store_find_certificate-13.0 {
        Find certificate - subject_name
    } -setup {
        # Choose CA (Intermediate Auth) so issuer not same as subject
        set hstore [twapi::cert_system_store_open CA]
        set cert [pick_cert $hstore]
        set subject_name [twapi::cert_subject_name $cert -name rdn]
    } -body {
        # Assumes exactly one cert with that pub key
        set cert2 [twapi::cert_store_find_certificate $hstore subject_name [twapi::cert_name_to_blob $subject_name]]
        string equal $subject_name [twapi::cert_subject_name $cert2 -name rdn]
    } -cleanup {
        twapi::cert_store_release $hstore
        twapi::cert_release $cert
        twapi::cert_release $cert2
    } -result 1

    test cert_store_find_certificate-13.1 {
        Find certificate - subject_name (fail)
    } -setup {
        set hstore [twapi::cert_system_store_open CA]
        set cert [pick_cert $hstore 0]
        set hstore2 [twapi::cert_file_store_open [temp_cert_file_store_path]]
        set subject_name [twapi::cert_subject_name $cert -name rdn]
    } -body {
        twapi::cert_store_find_certificate $hstore2 subject_name [twapi::cert_name_to_blob $subject_name]
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
        twapi::cert_store_release $hstore2
    } -result ""

    test cert_store_find_certificate-14.0 {
        Find certificate - subject_substring
    } -setup {
        # Choose CA (Intermediate Auth) so issuer not same as subject
        set hstore [twapi::cert_system_store_open CA]
    } -body {
        set cert [twapi::cert_store_find_certificate $hstore subject_substring microsoft]
        string match -nocase *microsoft* [twapi::cert_subject_name $cert -name rdn -format simple]
    } -cleanup {
        twapi::cert_release $cert
        twapi::cert_store_release $hstore
    } -result 1

    test cert_store_find_certificate-14.1 {
        Find certificate - subject_substring (fail)
    } -setup {
        # Choose CA (Intermediate Auth) so issuer not same as subject
        set hstore [twapi::cert_system_store_open CA]
    } -body {
        twapi::cert_store_find_certificate $hstore subject_substring XmicrosoftX
    } -cleanup {
        twapi::cert_store_release $hstore
    } -result ""

    test cert_store_find_certificate-14.2 {
        Find certificate - subject_substring (multiple)
    } -setup {
        # Choose CA (Intermediate Auth) so issuer not same as subject
        set hstore [twapi::cert_system_store_open CA]
    } -body {
        set count 0
        set matches 0
        set cert NULL
        while {1} {
            set cert [twapi::cert_store_find_certificate $hstore subject_substring microsoft $cert]
            if {$cert eq ""} break
            incr count
            incr matches [string match -nocase *microsoft* [twapi::cert_subject_name $cert -name rdn]]
        }
        list [expr {$count > 1}] [expr {$count == $matches}]
    } -cleanup {
        twapi::cert_store_release $hstore
    } -result {1 1}

    test cert_store_find_certificate-14.0 {
        TBD - Find certificate -subject_substring
    } -constraints {
        TBD
    } -setup {
    } -body {
    } -result TBD

    test cert_store_enum_contents {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_add_certificate {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_add_encoded_certificate {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_to_pfx {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_to_pkcs12 {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_to_pkcs7 {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_to_serialize {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_store_commit {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_subject_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_issuer_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_blob_to_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_name_to_blob {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_enum_properties {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_property {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_property_set {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_property_delete {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_set_key_prov {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_export {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_enhkey_usage {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_key_usage {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_thumbprint {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_info {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_extension {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_create_self_signed {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_create_self_signed_from_crypt_context {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_create {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_request {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD
    
    test cert_tls_verify {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test cert_locate_private_key {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_acquire {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_free {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_container_delete {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_generate {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_keypair {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_public_key {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_get_security_descriptor {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_set_security_descriptor {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_container_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_container_unique_name {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_csp {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_csptype {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_key_container_names {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_session_key_size {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_keyset_type {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD

    test crypt_symmetric_key_size {
        TBD
    } -body {
        TBD 
    } -constraints {
        TBD
    } -result TBD
}

twapi::crypto::test::cleanup_test_cert_files
::tcltest::cleanupTests
namespace delete ::twapi::crypto::test
