package require critcl
critcl::clean_cache
critcl::tcl 8.5

critcl::ccode {
#include "tcl.h"
#include <limits.h>

typedef int TCL_RESULT;

/* If building out of twapi pool, use its settings */
#if defined(TWAPI_ENABLE_ASSERT) && !defined(TARRAY_ENABLE_ASSERT)
#define TARRAY_ENABLE_ASSERT TWAPI_ENABLE_ASSERT
#endif


#if TARRAY_ENABLE_ASSERT
#  if TARRAY_ENABLE_ASSERT == 1
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (Tcl_Panic("Assertion (%s) failed at line %d in file %s.", #bool_, __LINE__, __FILE__), 0) )
#  elif TARRAY_ENABLE_ASSERT == 2
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (DebugOutput("Assertion (" #bool_ ") failed at line " MAKESTRINGLITERAL2(__LINE__) " in file " __FILE__ "\n"), 0) )
#  elif TARRAY_ENABLE_ASSERT == 3
#    define TARRAY_ASSERT(bool_) do { if (! (bool_)) { __asm int 3 } } while (0)
#  else
#    error Invalid value for TARRAY_ENABLE_ASSERT
#  endif
#else
#define TARRAY_ASSERT(bool_) ((void) 0)
#endif

typedef Tcl_Obj *TArrayObjPtr;

/*
 * TArray is a Tcl "type" used for densely storing arrays of elements
 * of a specific type.
 * The Tcl_Obj.internalRep.ptrAndLongRep.value type of an element.
 * and Tcl_Obj.internalRep.ptrAndLongRep.ptr holds a pointer to 
 * an allocated array of that type.
 */

static char *gTArrayTypeTokens[] = {
    "boolean",
#define TARRAY_BOOLEAN 0
    "int",
#define TARRAY_UINT 1
    "uint",
#define TARRAY_INT 2
    "wide",
#define TARRAY_WIDE 3
    "double",
#define TARRAY_DOUBLE 4
    "byte",
#define TARRAY_BYTE 5
    "tclobj",
#define TARRAY_OBJ 6
};    
#define TARRAY_TYPE_END (sizeof(gTArrayTypeTokens)/sizeof(gTArrayTypeTokens[0]))

/* How many slots to allocate by default */
#define TARRAY_DEFAULT_NSLOTS 1000

#define TARRAY_MAX_ELEM_SIZE (sizeof(double) > sizeof(int) ? (sizeof(double) > sizeof(void*) ? sizeof(double) : sizeof(void*)) : sizeof(int))
#define TARRAY_MAX_COUNT (1 + (int)(((size_t)UINT_MAX - sizeof(TArrayHdr))/TARRAY_MAX_ELEM_SIZE))

typedef union TArrayHdr_s {
    void *pointer_aligner;
    double double_aligner;
    struct {
        int type;
        int nrefs;              /* Ref count when shared between Tcl_Objs */
        int allocated;
        int used;
    };
} TArrayHdr;
#define TAHDRELEMPTR(thdr_, type_, index_) ((index_) + (type_ *)(sizeof(TArrayHdr) + (char *) (thdr_)))

#define TARRAYDATA(optr_)  ((optr_)->internalRep.ptrAndLongRep.ptr)
#define TARRAYHDR(optr_) ((TArrayHdr *)TARRAYDATA(optr_))
#define TARRAYTYPE(optr_) (TARRAYHDR(optr_)->type)
#define TARRAYELEMSLOTS(optr_) ((TARRAYHDR(optr_))->allocated)
#define TARRAYELEMCOUNT(optr_) ((TARRAYHDR(optr_))->used)
#define TARRAYELEMPTR(optr_, type_, index_) TAHDRELEMPTR(TARRAYHDR(optr_), type_, index_)

/* How much extra slots to allocate when allocating memory. n_ should
 * be number of elements currently.
 */
#define TARRAY_EXTRA(n_)  \
    ((n_) < 10 ? 10 : ((n_) < 100 ? (n_) : ((n_) < 800 ? 100 : ((n_)/8))))

#define TARRAY_OBJ_SETREP(optr_, thdr_) \
    do {                                        \
        (thdr_)->nrefs++;                       \
        TARRAYHDR(optr_) = thdr_;               \
        (optr_)->typePtr = &gTArrayType;         \
    } while (0)


static void DupTArray(Tcl_Obj *srcP, Tcl_Obj *dstP);
static void FreeTArray(Tcl_Obj *objP);
static void UpdateTArrayString(Tcl_Obj *objP);
static struct Tcl_ObjType gTArrayType = {
    "TArray",
    FreeTArray,
    DupTArray,
    UpdateTArrayString,
    NULL,     /* jenglish advises to keep this NULL */
};


/* ALLOCATE_ARRAY call should panic on failure to allocate */
#define TARRAY_ALLOCMEM ckalloc
#define TARRAY_FREEMEM(p_) if (p_) ckfree((char *)p_)
#define TARRAY_REALLOCMEM ckrealloc

static void BadTypePanic(int tatype)
{
    Tcl_Panic("Unknown tarray type %d", tatype);
}

/* Increments the ref counts of Tcl_Objs in a tarray making sure not
   to run past end of array */
static void TArrayIncrObjRefs(TArrayHdr *thdrP, int first, int count)
{
    register int i;
    register Tcl_Obj **objPP;

    if (thdrP->type == TARRAY_OBJ) {
        if ((first + count) > thdrP->used)
            count = thdrP->used - first;
        if (count <= 0)
            return;
        objPP = TAHDRELEMPTR(thdrP, Tcl_Obj *, first);
        for (i = 0; i < count; ++i, ++objPP) {
            Tcl_IncrRefCount(*objPP);
        }
    }
}

/* Decrements the ref counts of Tcl_Objs in a tarray.
   Does NOT CLEAR ANY OTHER HEADER FIELDS. CALLER MUST DO THAT 
*/
static void TArrayDecrObjRefs(TArrayHdr *thdrP, int first, int count)
{
    register int i;
    register Tcl_Obj **objPP;

    if (thdrP->type == TARRAY_OBJ) {
        if ((first + count) > thdrP->used)
            count = thdrP->used - first;
        if (count <= 0)
            return;
        objPP = TAHDRELEMPTR(thdrP, Tcl_Obj *, first);
        for (i = 0; i < count; ++i, ++objPP) {
            Tcl_DecrRefCount(*objPP);
        }
    }
}

static void TArrayFreeHdr(TArrayHdr *thdrP)
{
    if (thdrP->type == TARRAY_OBJ) {
        TArrayDecrObjRefs(thdrP);
    }
    if (--thdrP->nrefs <= 0)
        TARRAY_FREEMEM(thdrP);
}

static TCL_RESULT TArrayVerifyType(Tcl_Interp *interp, Tcl_Obj *objP)
{
    if (objP->typePtr == &gTArrayType)
        return TCL_OK;
    else {
        if (interp)
            Tcl_SetResult(interp, "Value is not a tarray", TCL_STATIC);
        return TCL_ERROR;
    }
}

static void FreeTArray(Tcl_Obj *objP)
{
    TArrayHdr *thdrP;

    TARRAY_ASSERT(srcP->typePtr == &gTArrayType);

    thdrP = TARRAYHDR(objP); 
    TARRAY_ASSERT(thdrP);

    TArrayFreeHdr(thdrP);
    TARRAYHDR(objP) = NULL;
    objP->typePtr = NULL;
}

static void DupTArray(Tcl_Obj *srcP, Tcl_Obj *dstP)
{
    TARRAY_ASSERT(srcP->typePtr == &gTArrayType);
    TARRAY_ASSERT(TARRAYDATA(srcP) != NULL);
        
    TARRAY_OBJ_SETREP(dstP, TARRAYHDR(srcP));
}


/* Called to generate a string implementation from an array of Tcl_Obj */
static void UpdateObjArrayString(
    Tcl_Obj *objP,
    Tcl_Obj **objv,             /* Must NOT be NULL */
    int objc                    /* Must NOT be 0 */
    )
{
    /* Copied almost verbatim from the Tcl's UpdateStringOfList */
#   define LOCAL_SIZE 20
    int localFlags[LOCAL_SIZE], *flagPtr = NULL;
    int i, length, bytesNeeded = 0;
    const char *elem;
    char *dst;

    TARRAY_ASSERT(objv);
    TARRAY_ASSERT(objc > 0);

    /*
     * Pass 1: estimate space, gather flags.
     */

    if (objc <= LOCAL_SIZE) {
        flagPtr = localFlags;
    } else {
        /*
         * We know objc <= TARRAY_MAX_OBJC, so this is safe.
         */

        flagPtr = (int *) ckalloc(objc * sizeof(int));
    }
    for (i = 0; i < objc; i++) {
        flagPtr[i] = (i ? TCL_DONT_QUOTE_HASH : 0);
        elem = Tcl_GetStringFromObj(objv[i], &length);
        bytesNeeded += Tcl_ScanCountedElement(elem, length, flagPtr+i);
        if (bytesNeeded < 0) {
            Tcl_Panic("max size for a Tcl value (%d bytes) exceeded", INT_MAX);
        }
    }
    if (bytesNeeded > INT_MAX - objc + 1) {
        Tcl_Panic("max size for a Tcl value (%d bytes) exceeded", INT_MAX);
    }
    bytesNeeded += objc;

    /*
     * Pass 2: copy into string rep buffer.
     */

    objP->length = bytesNeeded - 1;
    objP->bytes = ckalloc(bytesNeeded);
    dst = objP->bytes;
    for (i = 0; i < objc; i++) {
        flagPtr[i] |= (i ? TCL_DONT_QUOTE_HASH : 0);
        elem = Tcl_GetStringFromObj(objv[i], &length);
        dst += Tcl_ConvertCountedElement(elem, length, dst, flagPtr[i]);
        *dst++ = ' ';
    }
    objP->bytes[objP->length] = '\0';

    if (flagPtr != localFlags) {
        ckfree((char *) flagPtr);
    }
}


static void UpdateTArrayString(Tcl_Obj *objP)
{
    int i, n, count;
    int allocated, unused;
    char *cP;
    int max_elem_space;  /* Max space to print one element including
                            either terminating null or space */
    TArrayHdr *thdrP;
        
    TARRAY_ASSERT(objP->typePtr == &gTArrayType);

    objP->bytes = NULL;

    count = TARRAYELEMCOUNT(objP);
    if (count == 0) {
        objP->bytes = ckalloc(sizeof(objP->bytes[0]));
        objP->bytes[0] = 0;
        objP->length = 0;
        return;
    }

    thdrP = TARRAYHDR(objP);

    /* Code below based on count > 0 else terminating \0 will blow memory */

    /*
     * Special case Boolean since we know exactly how many chars will
     * be required 
     */

    /*
     * When output size cannot be calculated exactly, we allocate using
     * some estimate based on the type.
     */
        
    switch (TARRAYTYPE(objP)) {
    case TARRAY_BOOLEAN:
        {
            unsigned int *uiP = TAHDRELEMPTR(thdrP, unsigned int, 0);
            register unsigned int ui = *uiP;
            register unsigned int ui_mask;

            /* For BOOLEANS, we know how long a buffer needs to be */
            cP = ckalloc(2*count);
            objP->bytes = cP;
            n = count / 32;
            for (i = 0; i < n; ++i, ++uiP) {
                for (ui_mask = 1; ui_mask ; ui_mask <<= 1) {
                    *cP++ = (ui & ui_mask) ? '1' : '0';
                    *cP++ = ' ';
                }
            }
            n = count - n*32;    /* Left over bits in last byte */
            if (n) {
                ui = *uiP;
                for (i = 0, ui_mask = 1; i < n; ++i, ui_mask <<= 1) {
                    *cP++ = (ui & ui_mask) ? '1' : '0';
                    *cP++ = ' ';
                }
            }
            cP[-1] = 0;         /* Overwrite last space with terminating \0 */
            objP->length = 2*count - 1;
        }
        return;
                
    case TARRAY_OBJ:
        UpdateObjArrayString(objP, TAHDRELEMPTR(thdrP, Tcl_Obj *, 0), count);
        return;
                
    case TARRAY_UINT:
    case TARRAY_INT:
        TARRAY_ASSERT(sizeof(int) == 4); /* So max string space needed is 11 */
        max_elem_space = 11+1;
        break;
    case TARRAY_WIDE:
        max_elem_space = TCL_INTEGER_SPACE+1;
        break;
    case TARRAY_DOUBLE:
        max_elem_space = TCL_DOUBLE_SPACE+1;
        break;
    case TARRAY_BYTE:
        max_elem_space = 3+1;
        break;
    default:
        BadTypePanic(thdrP->type);
    }
            
    allocated = 0;
    unused = 0;
    objP->bytes= NULL;
    /* TBD - do Nested loop for efficiency reasons to avoid switch on every iter */
    for (i = 0; i < count; ++i) {
        if (unused < max_elem_space) {
            n = allocated - unused; /* Used space */
            /* Increase assuming remaining take half max space on average */
            allocated += ((max_elem_space + 1)/2)*(count - i);
            objP->bytes = ckrealloc(objP->bytes, allocated);
            cP = n + (char *) objP->bytes;
            unused = allocated - n;
        }
        switch (thdrP->type) {
        case TARRAY_UINT:
            _snprintf(cP, unused, "%u", *TAHDRELEMPTR(thdrP, unsigned int, i));
            break;
        case TARRAY_INT:
            _snprintf(cP, unused, "%d", *TAHDRELEMPTR(thdrP, int, i));
            break;
        case TARRAY_WIDE:
            _snprintf(cP, unused, "%" TCL_LL_MODIFIER "d", *TAHDRELEMPTR(thdrP, Tcl_WideInt, i));
            break;
        case TARRAY_DOUBLE:
            /* Do not use _snprintf because of slight difference
               it does not include decimal point for whole ints. For
               consistency with Tcl, use Tcl_PrintDouble instead */
            Tcl_PrintDouble(NULL, *TAHDRELEMPTR(thdrP, double, i), cP);
            break;
        case TARRAY_BYTE:
            _snprintf(cP, unused, "%u", *TAHDRELEMPTR(thdrP, unsigned char, i));
            break;
        }
        n = strlen(cP);
        cP += n;
        *cP++ = ' ';
        unused -= n+1;
    }

    cP[-1] = 0;         /* Overwrite last space with terminating \0 */
    objP->length = allocated - unused - 1; /* Terminating null not included in length */
            
    /* Only shrink array if unused space is comparatively too large */
    if (unused > (allocated / 8) && unused > 10)
        objP->bytes = ckrealloc(objP->bytes, allocated - unused);
    return;
}

/* thdrP must NOT be shared and must have enough slots */
static TCL_RESULT TArraySetFromObjs(Tcl_Interp *interp, TArrayHdr *thdrP,
                                 int first, int nelems,
                                 Tcl_Obj * const elems[])
{
    int i, ival;
    Tcl_WideInt wide;
    double dval;

    TARRAY_ASSERT(thdrP->nrefs < 2);

    if ((first + nelems) > thdrP->allocated) {
        /* Should really panic but not a fatal error (ie. no memory
         * corruption etc.). Most likely some code path did not check
         * size and allocate space accordingly.
         */
        Tcl_SetResult(interp, "Internal error: TArray too small.", TCL_STATIC);
        return TCL_ERROR;
    }

    /*
     * In case of conversion errors, we have to keep the old values
     * so we loop through first to verify there are no errors and then
     * a second time to actually store the values. The arrays can be
     * very large so we do not want to allocate a temporary
     * holding area for saving old values to be restored in case of errors.
     *
     * As a special optimization, when appending to the end, we do
     * not need to first check. We directly store the values and in case
     * of errors, simply restore the old size.
     *
     * Also for TARRAY_OBJ there is no question of conversion and hence
     * no question of conversion errors.
     */

    if (first < thdrP->used && thdrP->type != TARRAY_OBJ) {
        /* Not appending, need to verify conversion */
        switch (thdrP->type) {
        case TARRAY_BOOLEAN:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetBooleanFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
            }
            break;

        case TARRAY_UINT:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetWideIntFromObj(interp, elems[i], &wide) != TCL_OK)
                    goto convert_error;
                if (wide < 0 || wide > 0xFFFFFFFF) {
                    Tcl_SetObjResult(interp,
                                     Tcl_ObjPrintf("Integer \"%s\" too large for type \"uint\" typearray.", Tcl_GetString(elems[i])));
                    goto convert_error;
                }
            }
            break;

        case TARRAY_INT:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetIntFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
            }
            break;

        case TARRAY_WIDE:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetWideIntFromObj(interp, elems[i], &wide) != TCL_OK)
                    goto convert_error;
            }
            break;

        case TARRAY_DOUBLE:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetDoubleFromObj(interp, elems[i], &dval) != TCL_OK)
                    goto convert_error;
            }
            break;

        case TARRAY_BYTE:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetIntFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
                if (ival > 255 || ival < 255) {
                    Tcl_SetObjResult(interp,
                                     Tcl_ObjPrintf("Integer \"%d\" does not fit type \"byte\" typearray.", ival));
                    goto convert_error;
                }
            }
            break;
        default:
            BadTypePanic(thdrP->type);
        }
    }

    /*
     * Now actually store the values. Note we still have to check
     * status on conversion since we did not do checks when we are appending
     * to the end.
     */

    switch (thdrP->type) {
    case TARRAY_BOOLEAN:
        {
            register unsigned int *uiP;
            unsigned int ui, ui_mask;

            /* Take care of the initial condition where the first bit
               may not be aligned on a word boundary */
            uiP = TAHDRELEMPTR(thdrP, unsigned int, first / 32);
            ui_mask = (1 << (first & 31));
            ui = *uiP & ( ui_mask - 1);
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetBooleanFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
                if (ival)
                    ui |= ui_mask;
                ui_mask <<= 1;
                if (ui_mask == 0) {
                    *uiP++ = ui;
                    ui = 0;
                    ui_mask = 1;
                }
            }
            if (ui_mask != 1) {
                /* We have some leftover bits in ui that need to be stored.
                 * We need to *merge* these into the corresponding word
                 * keeping the existing high bits and setting the new low bits
                 */
                *uiP = (*uiP & -ui_mask) | ui; /* Assuming 2'complement math */
            }
        }
        break;

    case TARRAY_UINT:
        {
            register unsigned int *uintP;
            uintP = TAHDRELEMPTR(thdrP, unsigned int, first);
            for (i = 0; i < nelems; ++i, ++uintP) {
                if (Tcl_GetWideIntFromObj(interp, elems[i], &wide) != TCL_OK)
                    goto convert_error;
                if (wide < 0 || wide > 0xFFFFFFFF) {
                    Tcl_SetObjResult(interp,
                                     Tcl_ObjPrintf("Integer \"%s\" too large for type \"uint\" typearray.", Tcl_GetString(elems[i])));
                    goto convert_error;
                }
                *uintP = (unsigned int) wide;
            }
        }
        break;
    case TARRAY_INT:
        {
            register int *intP;
            intP = TAHDRELEMPTR(thdrP, int, first);
            for (i = 0; i < nelems; ++i, ++intP) {
                if (Tcl_GetIntFromObj(interp, elems[i], intP) != TCL_OK)
                    goto convert_error;
            }
        }
        break;

    case TARRAY_WIDE:
        {
            register Tcl_WideInt *wideP;
            wideP = TAHDRELEMPTR(thdrP, Tcl_WideInt, first);
            for (i = 0; i < nelems; ++i, ++wideP) {
                if (Tcl_GetWideIntFromObj(interp, elems[i], wideP) != TCL_OK)
                    goto convert_error;
            }
        }
        break;

    case TARRAY_DOUBLE:
        {
            register double *dblP;
            dblP = TAHDRELEMPTR(thdrP, double, first);
            for (i = 0; i < nelems; ++i, ++dblP) {
                if (Tcl_GetDoubleFromObj(interp, elems[i], dblP) != TCL_OK)
                    goto convert_error;
            }
        }
        break;

    case TARRAY_OBJ:
        {
            register Tcl_Obj **objPP;
            objPP = TAHDRELEMPTR(thdrP, Tcl_Obj *, first);
            for (i = 0; i < nelems; ++i, ++objPP) {
                /* Careful about the order here! */
                Tcl_IncrRefCount(elems[i]);
                if ((first + i) < thdrP->used) {
                    /* Deref what was originally in that slot */
                    Tcl_DecrRefCount(*objPP);
                }
                *objPP = elems[i];
            }
        }
        break;

    case TARRAY_BYTE:
        {
            register unsigned char *byteP;
            byteP = TAHDRELEMPTR(thdrP, unsigned char, first);
            for (i = 0; i < nelems; ++i, ++byteP) {
                if (Tcl_GetIntFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
                if (ival > 255 || ival < 255) {
                    Tcl_SetObjResult(interp,
                                     Tcl_ObjPrintf("Integer \"%d\" does not fit type \"byte\" typearray.", ival));
                    goto convert_error;
                }
                *byteP = (unsigned char) ival;
            }
        }
        break;

    default:
        BadTypePanic(thdrP->type);
    }

    if ((first + nelems) > thdrP->used)
        thdrP->used = first + nelems;

    return TCL_OK;

convert_error:                  /* Interp should already contain errors */
    TARRAY_ASSERT(thdrP->type != TARRAY_OBJ); /* Else we may need to deal with ref counts */

    return TCL_ERROR;

}

static int TArrayCalcSize(int tatype, int count)
{
    int space;

    switch (tatype) {
    case TARRAY_BOOLEAN:
        space = 4*((count+31)/32);
        break;
    case TARRAY_UINT:
    case TARRAY_INT:
        space = count * sizeof(int);
        break;
    case TARRAY_WIDE:
        space = count * sizeof(Tcl_WideInt);
        break;
    case TARRAY_DOUBLE:
        space = count * sizeof(double);
        break;
    case TARRAY_OBJ:
        space = count * sizeof(Tcl_Obj *);
        break;
    case TARRAY_BYTE:
        space = count * sizeof(unsigned char);
        break;
    default:
        BadTypePanic(tatype);
    }

    return sizeof(TArrayHdr) + space;
}

static TArrayHdr *TArrayRealloc(Tcl_Interp *interp, TArrayHdr *oldP, int new_count)
{
    TArrayHdr *thdrP;

    TARRAY_ASSERT(oldP->nrefs < 2);
    TARRAY_ASSERT(oldP->used <= new_count);

    thdrP = TARRAY_REALLOCMEM(oldP, TArrayCalcSize(oldP->type, new_count));
    thdrP->allocated = new_count;
    return thdrP;
}


static TArrayHdr * TArrayAlloc(Tcl_Interp *interp, int tatype,
                           int nelems, Tcl_Obj * const elems[],
                           int init_size)
{
    TArrayHdr *thdrP;
    int space;

    if (elems) {
        /*
         * Initialization provided. If explicit size specified, fix
         * at that else leave some extra space.
         */
        if (init_size) {
            if (init_size < nelems)
                init_size = nelems;
        } else {
            init_size = nelems + TARRAY_EXTRA(nelems);
        }
    } else {
        nelems = 0;
        if (init_size == 0)
            init_size = TARRAY_DEFAULT_NSLOTS;
    }

    thdrP = (TArrayHdr *) TARRAY_ALLOCMEM(TArrayCalcSize(tatype, init_size));
    thdrP->nrefs = 0;
    thdrP->type = tatype;
    thdrP->allocated = init_size;
    thdrP->used = nelems;

    if (elems != NULL && nelems != 0) {
        if (TArraySetFromObjs(interp, thdrP, 0, nelems, elems) != TCL_OK) {
            TARRAY_FREEMEM(thdrP);
            return NULL;
        }
    }

    return thdrP;

}

/* dstP must not be shared and must be large enough */
static TCL_RESULT TArraySet(Tcl_Interp *interp, TArrayHdr *dstP, int dst_first,
                             TArrayHdr *srcP, int src_first, int count)
{
    int i, nbytes;
    void *s, *d;
    Tcl_Obj *objPP;

    TARRAY_ASSERT(dstP->type == srcP->type);
    TARRAY_ASSERT(dstP->nrefs < 2); /* Must not be shared */

    if (src_first >= srcP->used || dstP == srcP)
        return TCL_OK;          /* Nothing to be copied */

    if ((src_first + count) > srcP->used)
        count = srcP->used - src_first;

    if (count <= 0)
        return TCL_OK;

    if (dst_first < 0)
        dst_first = 0;
    else if (dst_first > dstP->used)
        dst_first = dst_used;

    if ((dst_first + count) > dstP->allocated) {
        Tcl_SetResult(interp, "Internal error: TArray too small.", TCL_STATIC);
        return TCL_ERROR;
    }

    /*
     * For all types other than BOOLEAN and OBJ, we can just memcpy
     * Those two types have complication in that BOOLEANs are compacted
     * into int size words and the copy may not be aligned on a byte boundary.
     * For OBJ types, we have to deal with reference counts.
     */
    switch (srcP->type) {
    case TARRAY_BOOLEAN:
        /*
         * A bit bothersome because the source and destination starting bit
         * may not be aligned on word boundaries and the count may also
         * not be aligned.
         */

        if ((src_first & 31) == 0 && (dst_first & 31 == 0) && (count/32) == 0) {
            /* Both aligned, wonderful. Just do a memcpy of words like for other types */
            nbytes = (count/32) * sizeof(unsigned int);
            s = TAHDRELEMPTR(srcP, unsigned int, src_first);
            d = TAHDRELEMPTR(dstP, unsigned int, dst_first);
            break;
        }

        HERE
        nbytes = 4*((count+31)/32);
        break;
    case TARRAY_OBJ:
        /*
         * We have to deal with reference counts here. For the objects
         * we are copying (source) we need to increment the reference counts.
         * For objects in destination that we are overwriting, we need
         * to decrement reference counts.
         */

        TArrayIncrObjRefs(srcP, src_first, count); /* Do this first */
        /* Note this call take care of the case where count exceeds
         * actual number in dstP
         */
        TArrayDecrObjRefs(dstP, dst_first, count);
         
        /* Now we can just memcpy like the other types */
        nbytes = count * sizeof(Tcl_Obj *);
        s = TAHDRELEMPTR(srcP, Tcl_Obj *, src_first);
        d = TAHDRELEMPTR(dstP, Tcl_Obj *, dst_first);
        break;
    case TARRAY_UINT:
    case TARRAY_INT:
        nbytes = count * sizeof(int);
        s = TAHDRELEMPTR(srcP, int, src_first);
        d = TAHDRELEMPTR(dstP, int, dst_first);
        break;
    case TARRAY_WIDE:
        nbytes = count * sizeof(Tcl_WideInt);
        s = TAHDRELEMPTR(srcP, Tcl_WideInt, src_first);
        d = TAHDRELEMPTR(dstP, Tcl_WideInt, dst_first);
        break;
    case TARRAY_DOUBLE:
        nbytes = count * sizeof(double);
        s = TAHDRELEMPTR(srcP, double, src_first);
        d = TAHDRELEMPTR(dstP, double, dst_first);
        break;
    case TARRAY_BYTE:
        nbytes = count * sizeof(unsigned char);
        s = TAHDRELEMPTR(srcP, unsigned char, src_first);
        d = TAHDRELEMPTR(dstP, unsigned char, dst_first);
        break;
    default:
        BadTypePanic(srcP->type);
    }

    memcpy(d, s, nbytes);

    if ((dst_first + count) > dstP->used)
        dstP->used = dst_first + count;

    return TCL_OK;
}

static TArrayHdr * TArrayCopy(Tcl_Interp *interp,
                              TArrayHdr *srcP,
                              int low, int high)
{
    TArrayHdr *thdrP;
    int nbytes;
    int count;

    if (srcP->used == 0) {
        low = 0;
        count = 0;
    } else {
        if (low < 0)
            low = 0;
        if (high >= srcP->used)
            count = srcP->used - low;
        else
            count = high - low + 1;
        if (count < 0)
            count = 0;
    }

    /* TBD should we allocate more than needed ? */
    thdrP = TArrayAllocate(interp, srcP->type, 0, NULL, count ? count : 1);

    switch (srcP->type) {
    case TARRAY_BOOLEAN:
        /* Simple memcpy this does not work for booleans unless aligned
           properly 
        */
        HERE
        nbytes = 4*((count+31)/32);
        break;
    case TARRAY_UINT:
    case TARRAY_INT:
        nbytes = count * sizeof(int);
        break;
    case TARRAY_WIDE:
        nbytes = count * sizeof(Tcl_WideInt);
        break;
    case TARRAY_DOUBLE:
        nbytes = count * sizeof(double);
        break;
    case TARRAY_OBJ:
        nbytes = count * sizeof(Tcl_Obj *);
        break;
    case TARRAY_BYTE:
        nbytes = count * sizeof(unsigned char);
        break;
    default:
        BadTypePanic(srcP->type);
    }

    if (count) {
        memcpy(TAHDRELEMPTR(thdrP, char, 0), TAHDRELEMPTR(srcP, char, low), nbytes);
        thdrP->used = count;
        if (thdrP->type == TARRAY_OBJ) {
            TArrayIncrObjRefs(thdrP);
        }
    }

    return thdrP;
}


/* Returns a Tcl_Obj for a TArray slot. NOTE: WITHOUT its ref count incremented */
static Tcl_Obj * TArrayIndex(Tcl_Interp *interp, TArrayHdr *thdrP, int index)
{
    Tcl_Obj *objP;
    int offset;

    if (index >= thdrP->used) {
        if (interp)
            Tcl_SetResult(interp, "tarray index out of bounds", TCL_STATIC);
        return NULL;
    }

    switch (thdrP->type) {
    case TARRAY_BOOLEAN:
        offset = index / 32;
        index -= 32*offset;
        return Tcl_NewIntObj(0 != ((1 << index) & *TAHDRELEMPTR(thdrP, unsigned int, offset)));
    case TARRAY_UINT:
        return Tcl_NewWideIntObj(*TAHDRELEMPTR(thdrP, unsigned int, index));
    case TARRAY_INT:
        return Tcl_NewIntObj(*TAHDRELEMPTR(thdrP, int, index));
    case TARRAY_WIDE:
        return Tcl_NewWideIntObj(*TAHDRELEMPTR(thdrP, Tcl_WideInt, index));
    case TARRAY_DOUBLE:
        return Tcl_NewDoubleObj(*TAHDRELEMPTR(thdrP, double, index));
    case TARRAY_BYTE:
        return Tcl_NewIntObj(*TAHDRELEMPTR(thdrP, unsigned char, index));
    case TARRAY_OBJ:
        return *TAHDRELEMPTR(thdrP, Tcl_Obj *, index);
    }
}

/* Returns a TArrayHdr of type int. The header's ref count is incremented
 * so caller should call TArrayFreeHdr as appropriate
 */
static TArrayHdr *TArrayConvertToIndices(Tcl_Interp *interp, Tcl_Obj *objP)
{
    TArrayHdr *thdrP;
    Tcl_Obj **elems;
    int       nelems;

    /* Indices should be a tarray of ints. If not, treat as a list
     * and convert it that way. Though that is slower, it should be rare
     * as all tarray indices are returned already in the proper format.
     */
    if (objP->typePtr == &gTArrayType && TARRAYTYPE(objP) == TARRAY_INT) {
        thdrP = TARRAYHDR(objP);
        thdrP->nrefs++;
        return thdrP;
    }

    if (Tcl_ListObjGetElements(interp, objP, &nelems, &elems) != TCL_OK)
        return NULL;

    thdrP = TArrayAllocate(interp, TARRAY_INT, nelems, elems, 0);
    if (thdrP)
        thdrP->nrefs++;
    return thdrP;
}

/* Returns a newly allocated TArrayHdr (with ref count 0) containing the
   values from the specified indices */
static TArrayHdr *TArrayGetValues(Tcl_Interp *interp, TArrayHdr *srcP, TArrayHdr *indicesP)
{
    TArrayHdr *thdrP;
    int i, count;
    int *indexP;

    if (indicesP->type != TARRAY_INT) {
        Tcl_SetResult(interp, "Invalid type for tarray indices", TCL_STATIC);
        return NULL;
    }

    count = indicesP->used;
    thdrP = TArrayAllocate(interp, srcP->type, 0, 0, count);
    if (thdrP == 0 || count == 0)
        return thdrP;

    indexP = TAHDRELEMPTR(indicesP, int, 0);

    switch (srcP->type) {
    case TARRAY_BOOLEAN:
        {
            unsigned int *uiP = TAHDRELEMPTR(thdrP, unsigned int, 0);
            unsigned int ui, src_ui, ui_mask;
            for (i = 0, ui = 0, ui_mask = 1; i < count; ++i, ++indexP) {
                off = *indexP / 32;   /* Offset to word containing the bit */
                src_ui = *TAHDRELEMPTR(srcP, unsigned int, off); /* The word */
                if (src_ui & (1 << (*indexP - (off*32))))
                    ui |= ui_mask;
                ui_mask <<= 1;
                if (ui_mask == 0) {
                    *uiP++ = ui;
                    ui = 0;
                    ui_mask = 1;
                }
            }
            if (ui_mask != 1) {
                /* We have some leftover bits in ui that need to be stored. */
                *uiP = ui;
            }
        }
        break;
    case TARRAY_UINT:
    case TARRAY_INT:
        {
            unsigned int *uiP = TAHDRELEMPTR(thdrP, unsigned int, 0);
            for (i = 0; i < count; ++i, ++indexP, ++uiP)
                *uiP = *TAHDRELEMPTR(srcP, unsigned int, *indexP);
        }
        break;
    case TARRAY_WIDE:
        {
            Tcl_Wide *wideP = TAHDRELEMPTR(thdrP, Tcl_WideInt, 0);
            for (i = 0; i < count; ++i, ++indexP, ++wideP)
                *wideP = *TAHDRELEMPTR(srcP, Tcl_WideInt, *indexP);
        }
        break;
    case TARRAY_DOUBLE:
        {
            double *dblP = TAHDRELEMPTR(thdrP, double, 0);
            for (i = 0; i < count; ++i, ++indexP, ++dblP)
                *dblP = *TAHDRELEMPTR(srcP, double, *indexP);
        }
        break;
    case TARRAY_BYTE:
        {
            unsigned char *ucP = TAHDRELEMPTR(thdrP, unsigned char, 0);
            for (i = 0; i < count; ++i, ++indexP, ++ucP)
                *ucP = *TAHDRELEMPTR(srcP, unsigned char, *indexP);
        }
        break;
    case TARRAY_OBJ:
        {
            Tcl_Obj *objPP = TAHDRELEMPTR(thdrP, Tcl_Obj *, 0);
            for (i = 0; i < count; ++i, ++indexP, ++objPP) {
                *objPP = *TAHDRELEMPTR(srcP, Tcl_Obj *, *indexP);
                Tcl_IncrRefCount(*objPP);
            }
        }
        break;
    default:
        BadTypePanic(srcP->type);
    }

    thdrP->used = count;
    return thdrP;
}


}

critcl::argtype TArrayObjPtr {
    if (TArrayVerifyType(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

critcl::ccommand tarray::create {} {
    int i;
    int init_size;
    int tatype;
    Tcl_Obj *objP;
    Tcl_Obj **elems;
    int nelems;
    TArrayHdr *thdrP;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?COUNT?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], gTArrayTypeTokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK) {
	return TCL_ERROR;
    }

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
    }

    thdrP = TArrayAllocate(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    objP = Tcl_NewObj();
    Tcl_InvalidateStringRep(objP);
    TARRAY_OBJ_SETREP(objP, thdrP);

    Tcl_SetObjResult(interp, objP);
    return TCL_OK;
}

critcl::cproc tarray::size {Tcl_Interp* interp Tcl_Obj* taP} ok {
    if (TArrayVerifyType(interp, taP) != TCL_OK)
        return TCL_ERROR;
    Tcl_SetObjResult(interp, Tcl_NewIntObj(TARRAYELEMCOUNT(taP)));
    return TCL_OK;
}

critcl::cproc tarray::type {Tcl_Interp* interp TArrayObjPtr taP} ok {
    int tatype = TARRAYTYPE(taP);
    if (tatype >= TARRAY_TYPE_END)
        BadTypePanic(tatype);

    Tcl_SetObjResult(interp, Tcl_NewStringObj(gTArrayTypeTokens[tatype], -1));
    return TCL_OK;
}

critcl::cproc tarray::index {Tcl_Interp* interp TArrayObjPtr taP int index} ok {
    Tcl_Obj *objP = TArrayIndex(interp, TARRAYHDR(taP), index);
    if (objP) {
        Tcl_SetObjResult(interp, objP);
        return TCL_OK;
    } else
        return TCL_ERROR;
}

critcl::cproc tarray::range {Tcl_Interp* interp TArrayObjPtr taP int low Tcl_Obj* highP} ok {
    Tcl_Obj *objP;
    TArrayHdr *thdrP;
    int n;
    char *s;

    if (Tcl_GetIntFromObj(NULL, highP, &n) != TCL_OK) {
        s = Tcl_GetString(highP);
        if (strcmp(s, "end")) {
            if (interp != NULL) {
                Tcl_SetObjResult(interp, Tcl_ObjPrintf(
                                     "bad index '%s': must be 'end' or an integer value", s));
                Tcl_SetErrorCode(interp, "TARRAY", "VALUE", "INDEX", NULL);
            }
            return TCL_ERROR;
        }
        n = TARRAYELEMCOUNT(taP);
    }

    thdrP = TArrayCopy(interp, TARRAYHDR(taP), low, n);
    if (thdrP == NULL)
        return TCL_ERROR;

    objP = Tcl_NewObj();
    Tcl_InvalidateStringRep(objP);
    TARRAY_OBJ_SETREP(objP, thdrP);

    Tcl_SetObjResult(interp, objP);
    return TCL_OK;
}

critcl::cproc tarray::get {Tcl_Interp* interp TArrayObjPtr taP Tcl_Obj* indicesP} {
    TArrayHdr *thdrP = TArrayConvertToIndices(interp, indicesP);
    if (thdrP == NULL)
        return TCL_ERROR;

    

    TArrayFreeHdr(thdrP);
    return TCL_OK;
}
