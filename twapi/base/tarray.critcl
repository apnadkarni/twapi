package require critcl
critcl::clean_cache
critcl::tcl 8.5

critcl::ccode {
#include "tcl.h"
#include <limits.h>

/* If building out of twapi pool, use its settings */
#if defined(TWAPI_ENABLE_ASSERT) && !defined(TARRAY_ENABLE_ASSERT)
#define TARRAY_ENABLE_ASSERT TWAPI_ENABLE_ASSERT
#endif


#if TARRAY_ENABLE_ASSERT
#  if TARRAY_ENABLE_ASSERT == 1
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (Tcl_Panic("Assertion (%s) failed at line %d in file %s.", #bool_, __LINE__, __FILE__), 0) )
#  elif TARRAY_ENABLE_ASSERT == 2
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (DebugOutput("Assertion (" #bool_ ") failed at line " MAKESTRINGLITERAL2(__LINE__) " in file " __FILE__ "\n"), 0) )
#  elif TARRAY_ENABLE_ASSERT == 3
#    define TARRAY_ASSERT(bool_) do { if (! (bool_)) { __asm int 3 } } while (0)
#  else
#    error Invalid value for TARRAY_ENABLE_ASSERT
#  endif
#else
#define TARRAY_ASSERT(bool_) ((void) 0)
#endif

/*
 * TArray is a Tcl "type" used for densely storing arrays of elements
 * of a specific type.
 * The Tcl_Obj.internalRep.ptrAndLongRep.value type of an element.
 * and Tcl_Obj.internalRep.ptrAndLongRep.ptr holds a pointer to 
 * an allocated array of that type.
 */

static char *gTArrayTypeTokens[] = {
    "boolean",
#define TARRAY_BOOLEAN 0
    "int",
#define TARRAY_UINT 1
    "uint",
#define TARRAY_INT 2
    "wide",
#define TARRAY_WIDE 3
    "double",
#define TARRAY_DOUBLE 4
    "byte",
#define TARRAY_BYTE 5
    "tclobj",
#define TARRAY_OBJ 6
};    

/* How many slots to allocate by default */
#define TARRAY_DEFAULT_NSLOTS 1000

#define TARRAY_MAX_ELEM_SIZE                                            \
    (sizeof(double) > sizeof(int) ? (sizeof(double) > sizeof(void*) ? sizeof(double) : sizeof(void*)) : sizeof(int))
#define TARRAY_MAX_COUNT                                                \
    (1 + (int)(((size_t)UINT_MAX - sizeof(TArrayHdr))/TARRAY_MAX_ELEM_SIZE))

typedef union TArrayHdr_s {
    void *pointer_aligner;
    double double_aligner;
    struct {
        int type;
        int nrefs;              /* Ref count when shared between Tcl_Objs */
        int allocated;
        int used;
    };
} TArrayHdr;
#define TAHDRELEMPTR(thdr_, type_, index_)                              \
    ((index_) + (type_ *)(sizeof(TArrayHdr) + (char *) (thdr_)))

#define TARRAYDATA(optr_)  ((optr_)->internalRep.ptrAndLongRep.ptr)
#define TARRAYHDR(optr_) ((TArrayHdr *)TARRAYDATA(optr_))
#define TARRAYTYPE(optr_) (TARRAYHDR(optr_)->type)
#define TARRAYELEMSLOTS(optr_) ((TARRAYHDR(optr_))->allocated)
#define TARRAYELEMCOUNT(optr_) ((TARRAYHDR(optr_))->used)
#define TARRAYELEMPTR(optr_, type_, index_)             \
    TAHDRELEMPTR(TARRAYHDR(optr_), type_, index_)

/* How much extra slots to allocate when allocating memory. n_ should
 * be number of elements currently.
 */
#define TARRAY_EXTRA(n_)  \
    ((n_) < 10 ? 10 : ((n_) < 100 ? (n_) : ((n_) < 800 ? 100 : ((n_)/8))))

#define TARRAY_OBJ_SETREP(optr_, thdr_)         \
    do {                                        \
        (thdr_)->nrefs++;                       \
        TARRAYHDR(optr_) = thdr_;               \
        (optr_)->typePtr = &gTArrayType;         \
    } while (0)


static void DupTArray(Tcl_Obj *srcP, Tcl_Obj *dstP);
static void FreeTArray(Tcl_Obj *objP);
static void UpdateTArrayString(Tcl_Obj *objP);
static struct Tcl_ObjType gTArrayType = {
    "TArray",
    FreeTArray,
    DupTArray,
    UpdateTArrayString,
    NULL,     /* jenglish advises to keep this NULL */
};


/* ALLOCATE_ARRAY call should panic on failure to allocate */
#define TARRAY_ALLOCMEM ckalloc
#define TARRAY_FREEMEM(p_) if (p_) ckfree((char *)p_)

static void FreeTArray(Tcl_Obj *objP)
{
    TArrayHdr *thdrP;

    TARRAY_ASSERT(srcP->typePtr == &gTArrayType);

    thdrP = TARRAYHDR(objP); 
    TARRAY_ASSERT(thdrP);

    if (--thdrP->nrefs == 0)
        TARRAY_FREEMEM(thdrP);
    TARRAYHDR(objP) = NULL;
    objP->typePtr = NULL;
}

static void DupTArray(Tcl_Obj *srcP, Tcl_Obj *dstP)
{
    TARRAY_ASSERT(srcP->typePtr == &gTArrayType);
    TARRAY_ASSERT(TARRAYDATA(srcP) != NULL);
        
    TARRAY_OBJ_SETREP(dstP, TARRAYHDR(srcP));
}


/* Called to generate a string implementation from an array of Tcl_Obj */
static void UpdateObjArrayString(
    Tcl_Obj *objP,
    Tcl_Obj **objv,             /* Must NOT be NULL */
    int objc                    /* Must NOT be 0 */
    )
{
    /* Copied almost verbatim from the Tcl's UpdateStringOfList */
#   define LOCAL_SIZE 20
    int localFlags[LOCAL_SIZE], *flagPtr = NULL;
    int i, length, bytesNeeded = 0;
    const char *elem;
    char *dst;

    TARRAY_ASSERT(objv);
    TARRAY_ASSERT(objc > 0);

    /*
     * Pass 1: estimate space, gather flags.
     */

    if (objc <= LOCAL_SIZE) {
        flagPtr = localFlags;
    } else {
        /*
         * We know objc <= TARRAY_MAX_OBJC, so this is safe.
         */

        flagPtr = (int *) ckalloc(objc * sizeof(int));
    }
    for (i = 0; i < objc; i++) {
        flagPtr[i] = (i ? TCL_DONT_QUOTE_HASH : 0);
        elem = Tcl_GetStringFromObj(objv[i], &length);
        bytesNeeded += Tcl_ScanCountedElement(elem, length, flagPtr+i);
        if (bytesNeeded < 0) {
            Tcl_Panic("max size for a Tcl value (%d bytes) exceeded", INT_MAX);
        }
    }
    if (bytesNeeded > INT_MAX - objc + 1) {
        Tcl_Panic("max size for a Tcl value (%d bytes) exceeded", INT_MAX);
    }
    bytesNeeded += objc;

    /*
     * Pass 2: copy into string rep buffer.
     */

    objP->length = bytesNeeded - 1;
    objP->bytes = ckalloc(bytesNeeded);
    dst = objP->bytes;
    for (i = 0; i < objc; i++) {
        flagPtr[i] |= (i ? TCL_DONT_QUOTE_HASH : 0);
        elem = Tcl_GetStringFromObj(objv[i], &length);
        dst += Tcl_ConvertCountedElement(elem, length, dst, flagPtr[i]);
        *dst++ = ' ';
    }
    objP->bytes[objP->length] = '\0';

    if (flagPtr != localFlags) {
        ckfree((char *) flagPtr);
    }
}


static void UpdateTArrayString(Tcl_Obj *objP)
{
    int i, n, count;
    int allocated, unused;
    char *cP;
    unsigned char uc, uc_mask;
    unsigned char *ucP;
    int max_elem_space;  /* Max space to print one element including
                            either terminating null or space */
        
    TARRAY_ASSERT(objP->typePtr == &gTArrayType);

    objP->bytes = NULL;

    count = TARRAYELEMCOUNT(objP);
    if (count == 0) {
        objP->bytes = ckalloc(sizeof(objP->bytes[0]));
        objP->bytes[0] = 0;
        objP->length = 0;
        return;
    }

    /* Code below based on count > 0 else terminating \0 will blow memory */

    /*
     * Special case Boolean since we know exactly how many chars will
     * be required 
     */

    /*
     * When output size cannot be calculated exactly, we allocate using
     * some estimate based on the type.
     */
        
    switch (TARRAYTYPE(objP)) {
    case TARRAY_BOOLEAN:
        /* For BOOLEANS, we know how long a buffer needs to be */
        cP = ckalloc(2*count);
        objP->bytes = cP;
        ucP = TARRAYELEMPTR(objP, unsigned char, 0);
        n = count / 8;
        for (i = 0; i < n; ++i, ++ucP) {
            uc = *ucP;
            for (uc_mask = 1; uc_mask ; uc_mask <<= 1) {
                *cP++ = (uc & uc_mask) ? '1' : '0';
                *cP++ = ' ';
            }
        }
        n = count - n*8;    /* Left over bits in last byte */
        if (n) {
            uc = *ucP;
            for (i = 0, uc_mask = 1; i < n; ++i, uc_mask <<= 1) {
                *cP++ = (uc & uc_mask) ? '1' : '0';
                *cP++ = ' ';
            }
        }
        cP[-1] = 0;         /* Overwrite last space with terminating \0 */
        objP->length = 2*count - 1;
        return;
                
    case TARRAY_OBJ:
        UpdateObjArrayString(objP, TARRAYELEMPTR(objP, Tcl_Obj *, 0), count);
        return;
                
    case TARRAY_UINT:
    case TARRAY_INT:
        TARRAY_ASSERT(sizeof(int) == 4); /* So max string space needed is 11 */
        max_elem_space = 11+1;
        break;
    case TARRAY_WIDE:
        max_elem_space = TCL_INTEGER_SPACE+1;
        break;
    case TARRAY_DOUBLE:
        max_elem_space = TCL_DOUBLE_SPACE+1;
        break;
    case TARRAY_BYTE:
        max_elem_space = 3+1;
        break;
    default:
        Tcl_Panic("Unknown TypedArray type %d", TARRAYTYPE(objP));
    }
            
    allocated = 0;
    unused = 0;
    objP->bytes= NULL;
    /* TBD - do Nested loop for efficiency reasons to avoid switch on every iter */
    for (i = 0; i < count; ++i) {
        if (unused < max_elem_space) {
            n = allocated - unused; /* Used space */
            /* Increase assuming remaining take half max space on average */
            allocated += ((max_elem_space + 1)/2)*(count - i);
            objP->bytes = ckrealloc(objP->bytes, allocated);
            cP = n + (char *) objP->bytes;
            unused = allocated - n;
        }
        switch (TARRAYTYPE(objP)) {
        case TARRAY_UINT:
            _snprintf(cP, unused, "%u", *TARRAYELEMPTR(objP, unsigned int, i));
            break;
        case TARRAY_INT:
            _snprintf(cP, unused, "%d", *TARRAYELEMPTR(objP, int, i));
            break;
        case TARRAY_WIDE:
            _snprintf(cP, unused, "%" TCL_LL_MODIFIER "d", *TARRAYELEMPTR(objP, Tcl_WideInt, i));
            break;
        case TARRAY_DOUBLE:
            /* Do not use _snprintf because of slight difference
               it does not include decimal point for whole ints. For
               consistency with Tcl, use Tcl_PrintDouble instead */
            Tcl_PrintDouble(NULL, *TARRAYELEMPTR(objP, double, i), cP);
            break;
        case TARRAY_BYTE:
            _snprintf(cP, unused, "%u", *TARRAYELEMPTR(objP, unsigned char, i));
            break;
        }
        n = strlen(cP);
        cP += n;
        *cP++ = ' ';
        unused -= n+1;
    }

    cP[-1] = 0;         /* Overwrite last space with terminating \0 */
    objP->length = allocated - unused - 1; /* Terminating null not included in length */
            
    /* Only shrink array if unused space is comparatively too large */
    if (unused > (allocated / 8) && unused > 10)
        objP->bytes = ckrealloc(objP->bytes, allocated - unused);
    return;
}

TArrayHdr * TArrayAllocate(Tcl_Interp *interp, int tatype,
                           int nelems, Tcl_Obj * const elems[],
                           int init_size)
{
    TArrayHdr *thdrP;
    int i, space;

    if (elems) {
        /*
         * Initialization provided. If explicit size specified, fix
         * at that else leave some extra space.
         */
        if (init_size) {
            if (init_size < nelems)
                init_size = nelems;
        } else {
            init_size = nelems + TARRAY_EXTRA(nelems);
        }
    } else {
        nelems = 0;
        if (init_size == 0)
            init_size = TARRAY_DEFAULT_NSLOTS;
    }

    switch (tatype) {
    case TARRAY_BOOLEAN:
        space = (init_size+7)/8;
        break;
    case TARRAY_UINT:
    case TARRAY_INT:
        space = init_size * sizeof(int);
        break;
    case TARRAY_WIDE:
        space = init_size * sizeof(Tcl_WideInt);
        break;
    case TARRAY_DOUBLE:
        space = init_size * sizeof(double);
        break;
    case TARRAY_OBJ:
        space = init_size * sizeof(Tcl_Obj *);
        break;
    case TARRAY_BYTE:
        space = init_size * sizeof(unsigned char);
        break;
    default:
        Tcl_Panic("Unknown TypedArray type %d", tatype);
    }

    thdrP = (TArrayHdr *) TARRAY_ALLOCMEM(sizeof(TArrayHdr) + space);
    thdrP->nrefs = 0;
    thdrP->type = tatype;
    thdrP->allocated = init_size;
    thdrP->used = nelems;

    if (elems == NULL)
        return thdrP;       /* All done */

    switch (tatype) {
#ifdef TBD
    case TARRAY_BOOLEAN:
        TBD;
        break;
#endif
    case TARRAY_UINT:
    {
        Tcl_WideInt wide;
        register unsigned int *uintP;
        uintP = TAHDRELEMPTR(thdrP, unsigned int, 0);
        for (i = 0; i < nelems; ++i, ++uintP) {
            if (Tcl_GetWideIntFromObj(interp, elems[i], &wide) != TCL_OK)
                goto convert_error;
            if (wide < 0 || wide > 0xFFFFFFFF) {
                Tcl_SetObjResult(interp,
                                 Tcl_ObjPrintf("Integer \"%s\" too large for type \"uint\" typearray.", Tcl_GetString(elems[i])));
                goto convert_error;
            }
            *uintP = (unsigned int) wide;
        }
    }
    break;
    case TARRAY_INT:
    {
        register int *intP;
        intP = TAHDRELEMPTR(thdrP, int, 0);
        for (i = 0; i < nelems; ++i, ++intP) {
            if (Tcl_GetIntFromObj(interp, elems[i], intP) != TCL_OK)
                goto convert_error;
        }
    }
    break;

    case TARRAY_WIDE:
    {
        register Tcl_WideInt *wideP;
        wideP = TAHDRELEMPTR(thdrP, Tcl_WideInt, 0);
        for (i = 0; i < nelems; ++i, ++wideP) {
            if (Tcl_GetWideIntFromObj(interp, elems[i], wideP) != TCL_OK)
                goto convert_error;
        }
    }
    break;

    case TARRAY_DOUBLE:
    {
        register double *dblP;
        dblP = TAHDRELEMPTR(thdrP, double, 0);
        for (i = 0; i < nelems; ++i, ++dblP) {
            if (Tcl_GetDoubleFromObj(interp, elems[i], dblP) != TCL_OK)
                goto convert_error;
        }
    }
    break;

    case TARRAY_OBJ:
    {
        register Tcl_Obj **objPP;
        objPP = TAHDRELEMPTR(thdrP, Tcl_Obj *, 0);
        for (i = 0; i < nelems; ++i, ++objPP) {
            *objPP = elems[i];
            Tcl_IncrRefCount(*objPP);
        }
    }
    break;

    case TARRAY_BYTE:
    {
        register unsigned char *byteP;
        int ival;
        byteP = TAHDRELEMPTR(thdrP, unsigned char, 0);
        for (i = 0; i < nelems; ++i, ++byteP) {
            if (Tcl_GetIntFromObj(interp, elems[i], &ival) != TCL_OK)
                goto convert_error;
            if (ival > 255 || ival < 255) {
                Tcl_SetObjResult(interp,
                                 Tcl_ObjPrintf("Integer \"%d\" does not fit type \"byte\" typearray.", ival));
                goto convert_error;
            }
            *byteP = (unsigned char) ival;
        }
    }
    break;
    default:
        Tcl_Panic("Unknown TypedArray type %d", tatype);
    }

    return thdrP;

convert_error:
    TARRAY_ASSERT(tatype != TARRAY_OBJ);
    TARRAY_FREEMEM(thdrP);
    return NULL;
}

}


#critcl::csources typedarray.c

critcl::ccommand tarray::create {} {
    int i, opt;
    int init_size;
    int tatype;
    Tcl_Obj *objP;
    Tcl_Obj **elems;
    int nelems;
    TArrayHdr *thdrP;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?COUNT?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], gTArrayTypeTokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK) {
	return TCL_ERROR;
    }

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
    }

    thdrP = TArrayAllocate(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    objP = Tcl_NewObj();
    Tcl_InvalidateStringRep(objP);
    TARRAY_OBJ_SETREP(objP, thdrP);


    
    Tcl_SetObjResult(interp, objP);
    return TCL_OK;
}

