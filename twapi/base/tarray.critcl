package require critcl
critcl::clean_cache
critcl::tcl 8.5

critcl::cheaders tarray.h
critcl::ccode {
#include "tarray.h"
}
critcl::csources tarray.c

critcl::argtype TArrayObjPtr {
    if (TArrayVerifyType(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

critcl::ccommand tarray::create {} {
    int i;
    int init_size;
    int tatype;
    Tcl_Obj *objP;
    Tcl_Obj **elems;
    int nelems;
    TArrayHdr *thdrP;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?COUNT?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], gTArrayTypeTokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK) {
	return TCL_ERROR;
    }

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
    }

    thdrP = TArrayAlloc(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    Tcl_SetObjResult(interp, TArrayNewObj(thdrP));
    return TCL_OK;
}

critcl::cproc tarray::size {Tcl_Interp* interp Tcl_Obj* taP} ok {
    if (TArrayVerifyType(interp, taP) != TCL_OK)
        return TCL_ERROR;
    Tcl_SetObjResult(interp, Tcl_NewIntObj(TARRAYELEMCOUNT(taP)));
    return TCL_OK;
}

critcl::cproc tarray::type {Tcl_Interp* interp TArrayObjPtr taP} ok {
    int tatype = TARRAYTYPE(taP);

    Tcl_SetObjResult(interp, Tcl_NewStringObj(gTArrayTypeTokens[tatype], -1));
    return TCL_OK;
}

critcl::cproc tarray::index {Tcl_Interp* interp TArrayObjPtr taP int index} ok {
    Tcl_Obj *objP = TArrayIndex(interp, TARRAYHDR(taP), index);
    if (objP) {
        Tcl_SetObjResult(interp, objP);
        return TCL_OK;
    } else
        return TCL_ERROR;
}

critcl::cproc tarray::range {Tcl_Interp* interp TArrayObjPtr taP int low Tcl_Obj* highP} ok {
    TArrayHdr *thdrP;
    int high;
    int count;
    char *s;

    if (Tcl_GetIntFromObj(NULL, highP, &high) != TCL_OK) {
        s = Tcl_GetString(highP);
        if (strcmp(s, "end")) {
            if (interp != NULL) {
                Tcl_SetObjResult(interp, Tcl_ObjPrintf(
                                     "bad index '%s': must be 'end' or an integer value", s));
                Tcl_SetErrorCode(interp, "TARRAY", "VALUE", "INDEX", NULL);
            }
            return TCL_ERROR;
        }
        high = TARRAYELEMCOUNT(taP) - 1;
    }

    if (low < 0)
        low = 0;
    count = high-low+1;
    if (count < 0)
        count = 0;

    thdrP = TArrayAlloc(interp, TARRAYTYPE(taP), 0, NULL, count);
    if (thdrP == NULL)
        return TCL_ERROR;

    if (TArraySet(interp, thdrP, 0, TARRAYHDR(taP), low, count) != TCL_OK)
        return TCL_ERROR;

    Tcl_SetObjResult(interp, TArrayNewObj(thdrP));
    return TCL_OK;
}

critcl::cproc tarray::get {Tcl_Interp* interp TArrayObjPtr taP Tcl_Obj* indicesP} ok {
    TArrayHdr *valuesP;
    TArrayHdr *thdrP = TArrayConvertToIndices(interp, indicesP);
    
    if (thdrP == NULL)
        return TCL_ERROR;

    valuesP = TArrayGetValues(interp, TARRAYHDR(taP), thdrP);
    if (valuesP) {
        Tcl_SetObjResult(interp, TArrayNewObj(valuesP));
    }

    TArrayFreeHdr(thdrP);
    return valuesP ? TCL_OK : TCL_ERROR;
}

