package require critcl
critcl::clean_cache
critcl::tcl 8.5

critcl::ccode {
#include "tcl.h"
#include <limits.h>

typedef int TCL_RESULT;

/* If building out of twapi pool, use its settings */
#if defined(TWAPI_ENABLE_ASSERT) && !defined(TARRAY_ENABLE_ASSERT)
#define TARRAY_ENABLE_ASSERT TWAPI_ENABLE_ASSERT
#endif


#if TARRAY_ENABLE_ASSERT
#  if TARRAY_ENABLE_ASSERT == 1
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (Tcl_Panic("Assertion (%s) failed at line %d in file %s.", #bool_, __LINE__, __FILE__), 0) )
#  elif TARRAY_ENABLE_ASSERT == 2
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (DebugOutput("Assertion (" #bool_ ") failed at line " MAKESTRINGLITERAL2(__LINE__) " in file " __FILE__ "\n"), 0) )
#  elif TARRAY_ENABLE_ASSERT == 3
#    define TARRAY_ASSERT(bool_) do { if (! (bool_)) { __asm int 3 } } while (0)
#  else
#    error Invalid value for TARRAY_ENABLE_ASSERT
#  endif
#else
#define TARRAY_ASSERT(bool_) ((void) 0)
#endif

typedef Tcl_Obj *TArrayObjPtr;

/*
 * TArray is a Tcl "type" used for densely storing arrays of elements
 * of a specific type.
 * The Tcl_Obj.internalRep.ptrAndLongRep.value type of an element.
 * and Tcl_Obj.internalRep.ptrAndLongRep.ptr holds a pointer to 
 * an allocated array of that type.
 */

static char *gTArrayTypeTokens[] = {
    "boolean",
#define TARRAY_BOOLEAN 0
    "int",
#define TARRAY_UINT 1
    "uint",
#define TARRAY_INT 2
    "wide",
#define TARRAY_WIDE 3
    "double",
#define TARRAY_DOUBLE 4
    "byte",
#define TARRAY_BYTE 5
    "tclobj",
#define TARRAY_OBJ 6
};    
#define TARRAY_TYPE_END (sizeof(gTArrayTypeTokens)/sizeof(gTArrayTypeTokens[0]))

/* How many slots to allocate by default */
#define TARRAY_DEFAULT_NSLOTS 1000

#define TARRAY_MAX_ELEM_SIZE                                            \
    (sizeof(double) > sizeof(int) ? (sizeof(double) > sizeof(void*) ? sizeof(double) : sizeof(void*)) : sizeof(int))
#define TARRAY_MAX_COUNT                                                \
    (1 + (int)(((size_t)UINT_MAX - sizeof(TArrayHdr))/TARRAY_MAX_ELEM_SIZE))

typedef union TArrayHdr_s {
    void *pointer_aligner;
    double double_aligner;
    struct {
        int type;
        int nrefs;              /* Ref count when shared between Tcl_Objs */
        int allocated;
        int used;
    };
} TArrayHdr;
#define TAHDRELEMPTR(thdr_, type_, index_)                              \
    ((index_) + (type_ *)(sizeof(TArrayHdr) + (char *) (thdr_)))

#define TARRAYDATA(optr_)  ((optr_)->internalRep.ptrAndLongRep.ptr)
#define TARRAYHDR(optr_) ((TArrayHdr *)TARRAYDATA(optr_))
#define TARRAYTYPE(optr_) (TARRAYHDR(optr_)->type)
#define TARRAYELEMSLOTS(optr_) ((TARRAYHDR(optr_))->allocated)
#define TARRAYELEMCOUNT(optr_) ((TARRAYHDR(optr_))->used)
#define TARRAYELEMPTR(optr_, type_, index_)             \
    TAHDRELEMPTR(TARRAYHDR(optr_), type_, index_)

/* How much extra slots to allocate when allocating memory. n_ should
 * be number of elements currently.
 */
#define TARRAY_EXTRA(n_)  \
    ((n_) < 10 ? 10 : ((n_) < 100 ? (n_) : ((n_) < 800 ? 100 : ((n_)/8))))

#define TARRAY_OBJ_SETREP(optr_, thdr_)         \
    do {                                        \
        (thdr_)->nrefs++;                       \
        TARRAYHDR(optr_) = thdr_;               \
        (optr_)->typePtr = &gTArrayType;         \
    } while (0)


static void DupTArray(Tcl_Obj *srcP, Tcl_Obj *dstP);
static void FreeTArray(Tcl_Obj *objP);
static void UpdateTArrayString(Tcl_Obj *objP);
static struct Tcl_ObjType gTArrayType = {
    "TArray",
    FreeTArray,
    DupTArray,
    UpdateTArrayString,
    NULL,     /* jenglish advises to keep this NULL */
};


/* ALLOCATE_ARRAY call should panic on failure to allocate */
#define TARRAY_ALLOCMEM ckalloc
#define TARRAY_FREEMEM(p_) if (p_) ckfree((char *)p_)

static TCL_RESULT TArrayVerifyType(Tcl_Interp *interp, Tcl_Obj *objP)
{
    if (objP->typePtr == &gTArrayType)
        return TCL_OK;
    else {
        if (interp)
            Tcl_SetResult(interp, "Value is not a tarray", TCL_STATIC);
        return TCL_ERROR;
    }
}

static void FreeTArray(Tcl_Obj *objP)
{
    TArrayHdr *thdrP;

    TARRAY_ASSERT(srcP->typePtr == &gTArrayType);

    thdrP = TARRAYHDR(objP); 
    TARRAY_ASSERT(thdrP);

    if (--thdrP->nrefs == 0)
        TARRAY_FREEMEM(thdrP);
    TARRAYHDR(objP) = NULL;
    objP->typePtr = NULL;
}

static void DupTArray(Tcl_Obj *srcP, Tcl_Obj *dstP)
{
    TARRAY_ASSERT(srcP->typePtr == &gTArrayType);
    TARRAY_ASSERT(TARRAYDATA(srcP) != NULL);
        
    TARRAY_OBJ_SETREP(dstP, TARRAYHDR(srcP));
}


/* Called to generate a string implementation from an array of Tcl_Obj */
static void UpdateObjArrayString(
    Tcl_Obj *objP,
    Tcl_Obj **objv,             /* Must NOT be NULL */
    int objc                    /* Must NOT be 0 */
    )
{
    /* Copied almost verbatim from the Tcl's UpdateStringOfList */
#   define LOCAL_SIZE 20
    int localFlags[LOCAL_SIZE], *flagPtr = NULL;
    int i, length, bytesNeeded = 0;
    const char *elem;
    char *dst;

    TARRAY_ASSERT(objv);
    TARRAY_ASSERT(objc > 0);

    /*
     * Pass 1: estimate space, gather flags.
     */

    if (objc <= LOCAL_SIZE) {
        flagPtr = localFlags;
    } else {
        /*
         * We know objc <= TARRAY_MAX_OBJC, so this is safe.
         */

        flagPtr = (int *) ckalloc(objc * sizeof(int));
    }
    for (i = 0; i < objc; i++) {
        flagPtr[i] = (i ? TCL_DONT_QUOTE_HASH : 0);
        elem = Tcl_GetStringFromObj(objv[i], &length);
        bytesNeeded += Tcl_ScanCountedElement(elem, length, flagPtr+i);
        if (bytesNeeded < 0) {
            Tcl_Panic("max size for a Tcl value (%d bytes) exceeded", INT_MAX);
        }
    }
    if (bytesNeeded > INT_MAX - objc + 1) {
        Tcl_Panic("max size for a Tcl value (%d bytes) exceeded", INT_MAX);
    }
    bytesNeeded += objc;

    /*
     * Pass 2: copy into string rep buffer.
     */

    objP->length = bytesNeeded - 1;
    objP->bytes = ckalloc(bytesNeeded);
    dst = objP->bytes;
    for (i = 0; i < objc; i++) {
        flagPtr[i] |= (i ? TCL_DONT_QUOTE_HASH : 0);
        elem = Tcl_GetStringFromObj(objv[i], &length);
        dst += Tcl_ConvertCountedElement(elem, length, dst, flagPtr[i]);
        *dst++ = ' ';
    }
    objP->bytes[objP->length] = '\0';

    if (flagPtr != localFlags) {
        ckfree((char *) flagPtr);
    }
}


static void UpdateTArrayString(Tcl_Obj *objP)
{
    int i, n, count;
    int allocated, unused;
    char *cP;
    int max_elem_space;  /* Max space to print one element including
                            either terminating null or space */
    TArrayHdr *thdrP;
        
    TARRAY_ASSERT(objP->typePtr == &gTArrayType);

    objP->bytes = NULL;

    count = TARRAYELEMCOUNT(objP);
    if (count == 0) {
        objP->bytes = ckalloc(sizeof(objP->bytes[0]));
        objP->bytes[0] = 0;
        objP->length = 0;
        return;
    }

    thdrP = TARRAYHDR(objP);

    /* Code below based on count > 0 else terminating \0 will blow memory */

    /*
     * Special case Boolean since we know exactly how many chars will
     * be required 
     */

    /*
     * When output size cannot be calculated exactly, we allocate using
     * some estimate based on the type.
     */
        
    switch (TARRAYTYPE(objP)) {
    case TARRAY_BOOLEAN:
        {
            unsigned int *uiP = TAHDRELEMPTR(thdrP, unsigned int, 0);
            register unsigned int ui = *uiP;
            register unsigned int ui_mask;

            /* For BOOLEANS, we know how long a buffer needs to be */
            cP = ckalloc(2*count);
            objP->bytes = cP;
            n = count / 32;
            for (i = 0; i < n; ++i, ++uiP) {
                for (ui_mask = 1; ui_mask ; ui_mask <<= 1) {
                    *cP++ = (ui & ui_mask) ? '1' : '0';
                    *cP++ = ' ';
                }
            }
            n = count - n*32;    /* Left over bits in last byte */
            if (n) {
                ui = *uiP;
                for (i = 0, ui_mask = 1; i < n; ++i, ui_mask <<= 1) {
                    *cP++ = (ui & ui_mask) ? '1' : '0';
                    *cP++ = ' ';
                }
            }
            cP[-1] = 0;         /* Overwrite last space with terminating \0 */
            objP->length = 2*count - 1;
        }
        return;
                
    case TARRAY_OBJ:
        UpdateObjArrayString(objP, TAHDRELEMPTR(thdrP, Tcl_Obj *, 0), count);
        return;
                
    case TARRAY_UINT:
    case TARRAY_INT:
        TARRAY_ASSERT(sizeof(int) == 4); /* So max string space needed is 11 */
        max_elem_space = 11+1;
        break;
    case TARRAY_WIDE:
        max_elem_space = TCL_INTEGER_SPACE+1;
        break;
    case TARRAY_DOUBLE:
        max_elem_space = TCL_DOUBLE_SPACE+1;
        break;
    case TARRAY_BYTE:
        max_elem_space = 3+1;
        break;
    default:
        Tcl_Panic("Unknown TypedArray type %d", thdrP->type);
    }
            
    allocated = 0;
    unused = 0;
    objP->bytes= NULL;
    /* TBD - do Nested loop for efficiency reasons to avoid switch on every iter */
    for (i = 0; i < count; ++i) {
        if (unused < max_elem_space) {
            n = allocated - unused; /* Used space */
            /* Increase assuming remaining take half max space on average */
            allocated += ((max_elem_space + 1)/2)*(count - i);
            objP->bytes = ckrealloc(objP->bytes, allocated);
            cP = n + (char *) objP->bytes;
            unused = allocated - n;
        }
        switch (thdrP->type) {
        case TARRAY_UINT:
            _snprintf(cP, unused, "%u", *TAHDRELEMPTR(thdrP, unsigned int, i));
            break;
        case TARRAY_INT:
            _snprintf(cP, unused, "%d", *TAHDRELEMPTR(thdrP, int, i));
            break;
        case TARRAY_WIDE:
            _snprintf(cP, unused, "%" TCL_LL_MODIFIER "d", *TAHDRELEMPTR(thdrP, Tcl_WideInt, i));
            break;
        case TARRAY_DOUBLE:
            /* Do not use _snprintf because of slight difference
               it does not include decimal point for whole ints. For
               consistency with Tcl, use Tcl_PrintDouble instead */
            Tcl_PrintDouble(NULL, *TAHDRELEMPTR(thdrP, double, i), cP);
            break;
        case TARRAY_BYTE:
            _snprintf(cP, unused, "%u", *TAHDRELEMPTR(thdrP, unsigned char, i));
            break;
        }
        n = strlen(cP);
        cP += n;
        *cP++ = ' ';
        unused -= n+1;
    }

    cP[-1] = 0;         /* Overwrite last space with terminating \0 */
    objP->length = allocated - unused - 1; /* Terminating null not included in length */
            
    /* Only shrink array if unused space is comparatively too large */
    if (unused > (allocated / 8) && unused > 10)
        objP->bytes = ckrealloc(objP->bytes, allocated - unused);
    return;
}

/* thdrP must NOT be shared and must have enough slots */
static TCL_RESULT TArraySetElems(Tcl_Interp *interp, TArrayHdr *thdrP,
                                 int first, int nelems,
                                 Tcl_Obj * const elems[])
{
    int old_used;
    int i, ival;
    Tcl_WideInt wide;
    double dval;

    if (thdrP->nrefs > 1) {
        Tcl_Panic("TArraySetElems called on shared array");
    }

    if ((first + nelems) > thdrP->allocated) {
        /* Should really panic but not a fatal error (ie. no memory
         * corruption etc.). Most likely some code path did not check
         * size and allocate space accordingly.
         */
        Tcl_SetResult(interp, "Internal error: TArray too small.", TCL_STATIC);
        return TCL_ERROR;
    }

    /*
     * In case of conversion errors, we have to keep the old values
     * so we loop through first to verify there are no errors and then
     * a second time to actually store the values. The arrays can be
     * very large so we do not want to allocate a temporary
     * holding area for saving old values to be restored in case of errors.
     *
     * As a special optimization, when appending to the end, we do
     * not need to first check. We directly store the values and in case
     * of errors, simply restore the old size.
     *
     * Also for TARRAY_OBJ there is no question of conversion and hence
     * no question of conversion errors.
     */

    old_used = thdrP->used;
    if (first < old_used && thdrP->type != TARRAY_OBJ) {
        /* Not appending, need to verify conversion */
        switch (thdrP->type) {
        case TARRAY_BOOLEAN:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetBooleanFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
            }
            break;

        case TARRAY_UINT:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetWideIntFromObj(interp, elems[i], &wide) != TCL_OK)
                    goto convert_error;
                if (wide < 0 || wide > 0xFFFFFFFF) {
                    Tcl_SetObjResult(interp,
                                     Tcl_ObjPrintf("Integer \"%s\" too large for type \"uint\" typearray.", Tcl_GetString(elems[i])));
                    goto convert_error;
                }
            }
            break;

        case TARRAY_INT:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetIntFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
            }
            break;

        case TARRAY_WIDE:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetWideIntFromObj(interp, elems[i], &wide) != TCL_OK)
                    goto convert_error;
            }
            break;

        case TARRAY_DOUBLE:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetDoubleFromObj(interp, elems[i], &dval) != TCL_OK)
                    goto convert_error;
            }
            break;

        case TARRAY_BYTE:
            for (i = 0; i < nelems; ++i) {
                if (Tcl_GetIntFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
                if (ival > 255 || ival < 255) {
                    Tcl_SetObjResult(interp,
                                     Tcl_ObjPrintf("Integer \"%d\" does not fit type \"byte\" typearray.", ival));
                    goto convert_error;
                }
            }
            break;
        default:
            Tcl_Panic("Unknown TypedArray type %d", thdrP->type);
        }
    }

    /*
     * Now actually store the values. Note we still have to check
     * status on conversion since we did not do checks when we are appending
     * to the end.
     */

    switch (thdrP->type) {
    case TARRAY_BOOLEAN:
        {
            register unsigned int *uiP = TAHDRELEMPTR(thdrP, unsigned int, 0);
            unsigned int ui, ui_mask;
            for (i = 0, ui = 0, ui_mask = 1; i < nelems; ++i) {
                if (Tcl_GetBooleanFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
                if (ival)
                    ui |= ui_mask;
                ui_mask <<= 1;
                if (ui_mask == 0) {
                    /* One byte full */
                    *uiP++ = ui;
                    ui = 0;
                    ui_mask = 1;
                }
            }
            if (ui_mask != 1) {
                /* We have some leftover bits in ui that need to be stored. */
                *uiP = ui;
            }
        }
        break;

    case TARRAY_UINT:
        {
            register unsigned int *uintP;
            uintP = TAHDRELEMPTR(thdrP, unsigned int, 0);
            for (i = 0; i < nelems; ++i, ++uintP) {
                if (Tcl_GetWideIntFromObj(interp, elems[i], &wide) != TCL_OK)
                    goto convert_error;
                if (wide < 0 || wide > 0xFFFFFFFF) {
                    Tcl_SetObjResult(interp,
                                     Tcl_ObjPrintf("Integer \"%s\" too large for type \"uint\" typearray.", Tcl_GetString(elems[i])));
                    goto convert_error;
                }
                *uintP = (unsigned int) wide;
            }
        }
        break;
    case TARRAY_INT:
        {
            register int *intP;
            intP = TAHDRELEMPTR(thdrP, int, 0);
            for (i = 0; i < nelems; ++i, ++intP) {
                if (Tcl_GetIntFromObj(interp, elems[i], intP) != TCL_OK)
                    goto convert_error;
            }
        }
        break;

    case TARRAY_WIDE:
        {
            register Tcl_WideInt *wideP;
            wideP = TAHDRELEMPTR(thdrP, Tcl_WideInt, 0);
            for (i = 0; i < nelems; ++i, ++wideP) {
                if (Tcl_GetWideIntFromObj(interp, elems[i], wideP) != TCL_OK)
                    goto convert_error;
            }
        }
        break;

    case TARRAY_DOUBLE:
        {
            register double *dblP;
            dblP = TAHDRELEMPTR(thdrP, double, 0);
            for (i = 0; i < nelems; ++i, ++dblP) {
                if (Tcl_GetDoubleFromObj(interp, elems[i], dblP) != TCL_OK)
                    goto convert_error;
            }
        }
        break;

    case TARRAY_OBJ:
        {
            register Tcl_Obj **objPP;
            objPP = TAHDRELEMPTR(thdrP, Tcl_Obj *, 0);
            for (i = 0; i < nelems; ++i, ++objPP) {
                *objPP = elems[i];
                Tcl_IncrRefCount(*objPP);
            }
        }
        break;

    case TARRAY_BYTE:
        {
            register unsigned char *byteP;
            byteP = TAHDRELEMPTR(thdrP, unsigned char, 0);
            for (i = 0; i < nelems; ++i, ++byteP) {
                if (Tcl_GetIntFromObj(interp, elems[i], &ival) != TCL_OK)
                    goto convert_error;
                if (ival > 255 || ival < 255) {
                    Tcl_SetObjResult(interp,
                                     Tcl_ObjPrintf("Integer \"%d\" does not fit type \"byte\" typearray.", ival));
                    goto convert_error;
                }
                *byteP = (unsigned char) ival;
            }
        }
        break;

    default:
        Tcl_Panic("Unknown TypedArray type %d", thdrP->type);
    }

    return TCL_OK;

convert_error:                  /* Interp should already contain errors */
    TARRAY_ASSERT(thdrP->type != TARRAY_OBJ); /* Else we may need to deal with ref counts */
    thdrP->used = old_used;

    return TCL_ERROR;

}

static TArrayHdr * TArrayAllocate(Tcl_Interp *interp, int tatype,
                           int nelems, Tcl_Obj * const elems[],
                           int init_size)
{
    TArrayHdr *thdrP;
    int space;

    if (elems) {
        /*
         * Initialization provided. If explicit size specified, fix
         * at that else leave some extra space.
         */
        if (init_size) {
            if (init_size < nelems)
                init_size = nelems;
        } else {
            init_size = nelems + TARRAY_EXTRA(nelems);
        }
    } else {
        nelems = 0;
        if (init_size == 0)
            init_size = TARRAY_DEFAULT_NSLOTS;
    }

    switch (tatype) {
    case TARRAY_BOOLEAN:
        space = (init_size+31)/32;
        break;
    case TARRAY_UINT:
    case TARRAY_INT:
        space = init_size * sizeof(int);
        break;
    case TARRAY_WIDE:
        space = init_size * sizeof(Tcl_WideInt);
        break;
    case TARRAY_DOUBLE:
        space = init_size * sizeof(double);
        break;
    case TARRAY_OBJ:
        space = init_size * sizeof(Tcl_Obj *);
        break;
    case TARRAY_BYTE:
        space = init_size * sizeof(unsigned char);
        break;
    default:
        Tcl_Panic("Unknown TypedArray type %d", tatype);
    }

    thdrP = (TArrayHdr *) TARRAY_ALLOCMEM(sizeof(TArrayHdr) + space);
    thdrP->nrefs = 0;
    thdrP->type = tatype;
    thdrP->allocated = init_size;
    thdrP->used = nelems;

    if (elems != NULL && nelems != 0) {
        if (TArraySetElems(interp, thdrP, 0, nelems, elems) != TCL_OK) {
            TARRAY_FREEMEM(thdrP);
            return NULL;
        }
    }

    return thdrP;

}

/* Returns a Tcl_Obj for a TArray slot. NOTE: WITHOUT its ref count incremented */
static Tcl_Obj * TArrayIndex(Tcl_Interp *interp, TArrayHdr *thdrP, int index)
{
    Tcl_Obj *objP;
    int offset;

    if (index >= thdrP->used) {
        if (interp)
            Tcl_SetResult(interp, "tarray index out of bounds", TCL_STATIC);
        return NULL;
    }

    switch (thdrP->type) {
    case TARRAY_BOOLEAN:
        offset = index / 32;
        index -= 32*offset;
        return Tcl_NewIntObj(0 != ((1 << index) & *TAHDRELEMPTR(thdrP, unsigned int, offset)));
    case TARRAY_UINT:
        return Tcl_NewWideIntObj(*TAHDRELEMPTR(thdrP, unsigned int, index));
    case TARRAY_INT:
        return Tcl_NewIntObj(*TAHDRELEMPTR(thdrP, int, index));
    case TARRAY_WIDE:
        return Tcl_NewWideIntObj(*TAHDRELEMPTR(thdrP, Tcl_WideInt, index));
    case TARRAY_DOUBLE:
        return Tcl_NewDoubleObj(*TAHDRELEMPTR(thdrP, double, index));
    case TARRAY_BYTE:
        return Tcl_NewIntObj(*TAHDRELEMPTR(thdrP, unsigned char, index));
    case TARRAY_OBJ:
        return *TAHDRELEMPTR(thdrP, Tcl_Obj *, index);
    }
}


}

critcl::argtype TArrayObjPtr {
    if (TArrayVerifyType(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

critcl::ccommand tarray::create {} {
    int i;
    int init_size;
    int tatype;
    Tcl_Obj *objP;
    Tcl_Obj **elems;
    int nelems;
    TArrayHdr *thdrP;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?COUNT?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], gTArrayTypeTokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK) {
	return TCL_ERROR;
    }

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
    }

    thdrP = TArrayAllocate(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    objP = Tcl_NewObj();
    Tcl_InvalidateStringRep(objP);
    TARRAY_OBJ_SETREP(objP, thdrP);

    Tcl_SetObjResult(interp, objP);
    return TCL_OK;
}

critcl::cproc tarray::size {Tcl_Interp* interp Tcl_Obj* taP} ok {
    if (TArrayVerifyType(interp, taP) != TCL_OK)
        return TCL_ERROR;
    Tcl_SetObjResult(interp, Tcl_NewIntObj(TARRAYELEMCOUNT(taP)));
    return TCL_OK;
}

critcl::cproc tarray::type {Tcl_Interp* interp TArrayObjPtr taP} ok {
    int tatype = TARRAYTYPE(taP);
    if (tatype >= TARRAY_TYPE_END)
        Tcl_Panic("Unexpected tarray type %d in Tcl_Obj", tatype);

    Tcl_SetObjResult(interp, Tcl_NewStringObj(gTArrayTypeTokens[tatype], -1));
    return TCL_OK;
}

critcl::cproc tarray::index {Tcl_Interp* interp TArrayObjPtr taP int index} ok {
    Tcl_Obj *objP = TArrayIndex(interp, TARRAYHDR(taP), index);
    if (objP) {
        Tcl_SetObjResult(interp, objP);
        return TCL_OK;
    } else
        return TCL_ERROR;
}

critcl::cproc tarray::range {Tcl_Interp* interp TArrayObjPtr taP int low Tcl_Obj* {high 0}} ok {
    Tcl_SetObjResult(interp, high);
    return TCL_OK;
}
