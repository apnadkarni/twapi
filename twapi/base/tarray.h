#ifndef TARRAY_H
#define TARRAY_H

typedef int TCL_RESULT;

/* If building out of twapi pool, use its settings */
#if defined(TWAPI_ENABLE_ASSERT) && !defined(TARRAY_ENABLE_ASSERT)
#define TARRAY_ENABLE_ASSERT TWAPI_ENABLE_ASSERT
#endif


#if TARRAY_ENABLE_ASSERT
#  if TARRAY_ENABLE_ASSERT == 1
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (Tcl_Panic("Assertion (%s) failed at line %d in file %s.", #bool_, __LINE__, __FILE__), 0) )
#  elif TARRAY_ENABLE_ASSERT == 2
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (DebugOutput("Assertion (" #bool_ ") failed at line " MAKESTRINGLITERAL2(__LINE__) " in file " __FILE__ "\n"), 0) )
#  elif TARRAY_ENABLE_ASSERT == 3
#    define TARRAY_ASSERT(bool_) do { if (! (bool_)) { __asm int 3 } } while (0)
#  else
#    error Invalid value for TARRAY_ENABLE_ASSERT
#  endif
#else
#define TARRAY_ASSERT(bool_) ((void) 0)
#endif

typedef Tcl_Obj *TArrayObjPtr;

extern char *gTArrayTypeTokens[];

/* How many slots to allocate by default */
#define TARRAY_DEFAULT_NSLOTS 1000

#define TARRAY_MAX_ELEM_SIZE (sizeof(double) > sizeof(int) ? (sizeof(double) > sizeof(void*) ? sizeof(double) : sizeof(void*)) : sizeof(int))
#define TARRAY_MAX_COUNT (1 + (int)(((size_t)UINT_MAX - sizeof(TArrayHdr))/TARRAY_MAX_ELEM_SIZE))

typedef union TArrayHdr_s {
    void *pointer_aligner;
    double double_aligner;
    struct {
        int type;
        int nrefs;              /* Ref count when shared between Tcl_Objs */
        int allocated;
        int used;
    };
} TArrayHdr;
#define TAHDRELEMPTR(thdr_, type_, index_) ((index_) + (type_ *)(sizeof(TArrayHdr) + (char *) (thdr_)))

#define TARRAYDATA(optr_)  ((optr_)->internalRep.ptrAndLongRep.ptr)
#define TARRAYHDR(optr_) ((TArrayHdr *)TARRAYDATA(optr_))
#define TARRAYTYPE(optr_) (TARRAYHDR(optr_)->type)
#define TARRAYELEMSLOTS(optr_) ((TARRAYHDR(optr_))->allocated)
#define TARRAYELEMCOUNT(optr_) ((TARRAYHDR(optr_))->used)
#define TARRAYELEMPTR(optr_, type_, index_) TAHDRELEMPTR(TARRAYHDR(optr_), type_, index_)

/* How much extra slots to allocate when allocating memory. n_ should
 * be number of elements currently.
 */
#define TARRAY_EXTRA(n_)  \
    ((n_) < 10 ? 10 : ((n_) < 100 ? (n_) : ((n_) < 800 ? 100 : ((n_)/8))))

extern struct Tcl_ObjType gTArrayType;
#define TARRAY_OBJ_SETREP(optr_, thdr_) \
    do {                                        \
        (thdr_)->nrefs++;                       \
        TARRAYHDR(optr_) = thdr_;               \
        (optr_)->typePtr = &gTArrayType;         \
    } while (0)




/* ALLOCATE_ARRAY call should panic on failure to allocate */
#define TARRAY_ALLOCMEM ckalloc
#define TARRAY_FREEMEM(p_) if (p_) ckfree((char *)p_)
#define TARRAY_REALLOCMEM ckrealloc

/* Prototypes - generated by cl */
extern void __cdecl TArrayTypePanic(int tatype);
extern void __cdecl TArrayIncrObjRefs(union TArrayHdr_s *thdrP,int first,int count);
extern void __cdecl TArrayDecrObjRefs(union TArrayHdr_s *thdrP,int first,int count);
extern void __cdecl TArrayFreeHdr(union TArrayHdr_s *thdrP);
extern int __cdecl TArrayVerifyType(struct Tcl_Interp *interp,struct Tcl_Obj *objP);
extern int __cdecl TArraySetFromObjs(struct Tcl_Interp *interp,union TArrayHdr_s *thdrP,int first,int nelems,struct Tcl_Obj *const *elems );
extern int __cdecl TArrayCalcSize(int tatype,int count);
extern union TArrayHdr_s *__cdecl TArrayRealloc(struct Tcl_Interp *interp,union TArrayHdr_s *oldP,int new_count);
extern union TArrayHdr_s *__cdecl TArrayAlloc(struct Tcl_Interp *interp,int tatype,int nelems,struct Tcl_Obj *const *elems ,int init_size);
extern int __cdecl TArraySet(struct Tcl_Interp *interp,union TArrayHdr_s *dstP,int dst_first,union TArrayHdr_s *srcP,int src_first,int count);
extern struct Tcl_Obj *__cdecl TArrayIndex(struct Tcl_Interp *interp,union TArrayHdr_s *thdrP,int index);
extern union TArrayHdr_s *__cdecl TArrayConvertToIndices(struct Tcl_Interp *interp,struct Tcl_Obj *objP);
extern union TArrayHdr_s *__cdecl TArrayGetValues(struct Tcl_Interp *interp,union TArrayHdr_s *srcP,union TArrayHdr_s *indicesP);


#endif
