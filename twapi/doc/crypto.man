[comment {-*- tcl -*- doctools manpage}]
[manpage_begin "Cryptographic API" n ""]
[copyright "2007-2009 Ashok P. Nadkarni"]
[moddesc "Cryptographic API"]
[titledesc "Commands related to cryptographical operations"]
[require twapi_crypto]
[description]
[para]

[emph "This module is still experimental and liable to change."]

[para]
This package provides procedures related to cryptographic services
provided by the Windows platforms including 
privacy, authentication
and integrity.

[section "Overview"]

This page describes the commands related to the Win32 CryptoAPI which
includes functions related to encryption, decryption, signatures
and ancillary services for certificate and key management.

[para]
The Win32 CryptoAPI includes the Security Support Provider Interface (SSPI)
related to secure communication protocols.
Those commands are documented separately on the [uri sspi.html "SSPI page"].

[para]
This documentation expects the reader is familiar with the use of cryptography.
An overview of the concepts in the CryptoAPI is provided but the API itself
is fairly complex and the reader may wish to
refer to the
[uri http://msdn.microsoft.com/en-us/library/windows/desktop/aa380255(v=vs.85).aspx "Windows SDK CryptoAPI documentation"] for detailed guides
and reference documentation.

[section "Cryptographic Service Providers"]
A Cryptographic Service Providers (CSP) on Windows is a software module that 
implements a set of cryptographical functions such as encryption
or key storage.
There may be multiple such
modules on a system, each implementing one of more cryptographic algorithms
for one or more cryptographic functions. Applications implement cryptographic
operations by calling a standard interface defined by Windows
and implemented by the CSPs.

[para]
Some CSP's come with the Windows operating system while others are
implemented by third parties. The feature set implemented by each CSP
is different and can depend on factors such as
the operating system version, and because of US export restrictions,
the country. Based on the supported features, CSP's have an associated
CSP type. For example, a CSP of type [const PROV_RSA_FULL] supports
digital signatures and encryption using the RSA public key algorithm.
On the other hand, a CSP of type [const PROV_DSS] uses the DSA algorithm and
only supports hashes and signatures. When creating a
[sectref "Cryptographic contexts"], an application needs to specify 
a CSP type that supports the desired operations.

[para]
Two standard providers shipped as part of Windows are
[const "Microsoft Base Cryptographic Provider"]
and the
[const "Microsoft Strong Cryptographic Provider"].
On most systems, the latter is the default when no specific CSP is selected
and is sufficient in most cases unless some special functionality like
hardware based cryptography is desired.

[section "Keys and key containers"]
The keys used for cryptographic operations are stored in 
[emph "key containers"] within a CSP's control.
The keys are not generally exposed directly to an application but rather
the CSP carries out the operations using the keys on the application's behalf.

[para]
A CSP may be associated with multiple key containers, each identified by a name.
The specific key container and the keys within that container that
are used for an operation depends on the 
[sectref "Cryptographic contexts"] is bound at the time the context is
created via the [uri #crypt_context_acquire [cmd crypt_context_acquire]]
command. This command also allows creation of new key containers within
a CSP if they do not exist. 

[para]
To delete key containers, use the
[uri #crypt_key_container_delete [cmd crypt_key_container_delete]] command.

[para]
Depending on the CSP chosen, key containers may be empty when created. 
The command [uri #crypt_context_generate_key [cmd crypt_context_generate_key]]
adds keys to the container. The algorithm with which the key will be
used and the purpose (encryption, signing etc.) can be specified
so the appropriate type of key is generated. The container may
contain multiple keys and appropriate key must be chosen when
cryptographic operations are invoked.

[para]
A key container may be created as a user key set or a computer key set.
These are distinguished based on where they are stored and
who has access to them.
Refer to the [uri http://msdn.microsoft.com/en-us/library/windows/desktop/aa380255(v=vs.85).aspx "Windows SDK CryptoAPI documentation"]
for details. It is possible to change the default access permissions
for a key container. The
[uri #crypt_context_security_descriptor [cmd crypt_context_security_descriptor]]
command can be used retrieve and change the security descriptor for
a key container.

[para]
The key algorithm is specified using mnemonics such as [const 3des],
[const sha256] etc. In some cases, the key is identified not by
the algorithm but the intended use. In particular,
in the case of public key cryptography, two types of keys
are commonly used - one for signing, and one for exchanging a symmetric
key for encryption. When generating keys or selecting them
for operations, these are identified as [const signature] and
[const keyexchange] respectively. For a list of algorithm identifiers
see the description of 
[uri #crypt_context_generate_key [cmd crypt_context_generate_key]].
Note that not all algorithms are supported on all platforms.

[section "Cryptographic contexts"]
In order to perform cryptographic operations, an application must
choose a CSP, the algorithms to use and their parameters including keys.
The command [uri #crypt_context_acquire [cmd crypt_context_acquire]]
takes these are parameters and
returns a handle to a [emph "cryptographic context"] that
binds the desired combination together. This handle can then be used
in further cryptographic operation.

[para]
Once a context is created, the various parameters associated with it can
be retrieved.
[list_begin bullet]
[bullet]
[uri #crypt_context_csp [cmd crypt_context_csp]] returns the name
of the owning CSP.
[bullet]
[uri #crypt_context_csptype [cmd crypt_context_csptype]] returns the type
of the CSP.
[bullet]
[uri #crypt_context_key_container [cmd crypt_context_key_container]]
returns the name of key container currently associated with the context.
[bullet]
[uri #crypt_context_key_containers [cmd crypt_context_key_containers]]
returns the names of the other key containers owned by the CSP.
[bullet]
[uri #crypt_context_get_key [cmd crypt_context_get_key]] returns the
keys in the container.
[bullet]
[uri #crypt_context_keyset_type [cmd crypt_context_keyset_type]] returns
whether the key set in the container is per-user or per-machine.
[uri #crypt_context_session_key_size [cmd crypt_context_session_key_size]] 
and
[uri #crypt_context_symmetric_key_size [cmd crypt_context_symmetric_key_size]]
return the size of the keys in the container.

[list_end]

When no longer needed, cryptographic contexts must be freed with
the [uri #crypt_context_free [cmd crypt_context_free]] command.

[section "Certificate stores"]
The CryptoAPI interface provides functions for handling and storage of
X.509 digital certificates.
A [emph "certificate store"] is a container for certificates.
The container may be a physical store, for example on disk,
or a logical store which is a collection of physical stores presented
to the application as a single store.
Certificate stores may also be created as in-memory temporary stores 
which are not persisted.
[para]
Certain certificate stores, called [emph "system stores"]
are predefined by Windows. These include the stores [const MY],
[const ROOT], [const Trust] and [const CA]. Most applications should
store certificates in either the [const MY] store, or in their
own custom store.
[para]
Note that the system stores are relative to a [emph "system store location"]
which must be specified when opening the store.
These locations are specified in the following table:

[list_begin opt]
[opt_def [const user]] Certificates associated with the current user account.
[opt_def [const users]] Certificates shared among all user accounts on the system.
[opt_def [const service]] Certificates associated with the current service account.
[opt_def [const services]] Certificates shared among all services on the system.
[opt_def [const localmachine]] Certificates associated with the system.
[opt_def [const localmachineenterprise]] Certificates downloaded from the
global enterprise directory.
[opt_def [const localmachinegrouppolicy]] Certificates associated with the group policy for the system.
[opt_def [const usergrouppolicy]]  Certificates associated with the group policy for the current user.
[list_end]

Most certificate store operations require the store to be first opened
using the one of the commands
[uri #cert_system_store_open [cmd cert_system_store_open]],
[uri #cert_physical_store_open [cmd cert_physical_store_open]],
[uri #cert_file_store_open [cmd cert_file_store_open]] and
[uri #cert_memory_store_open [cmd cert_memory_store_open]]
as appropriate. These commands will optionally create the store
if it does not exist.
The handle returned from these commands must be passed to any
commands that operate on stores and released by calling
[uri #cert_store_close [cmd cert_store_close]] when no longer required.

[para]
Existing certificate stores can be deleted using the commands
[uri #cert_system_store_delete [cmd cert_system_store_delete]],
[uri #cert_physical_store_delete [cmd cert_physical_store_delete]] and
[uri #cert_file_store_delete [cmd cert_file_store_delete]].
A in-memory certificate store is deleted when its handle is closed.

[section "Certificate properties"]
When a certificate is placed
in a store, it is associated with additional properties that are not
part of the certificate itself, for example a private key associated
with the certificate. These properties can be enumerated
with [uri #cert_enum_properties [cmd cert_enum_properties]]
and the value of an individual property can be retrieved with
[uri #cert_get_property [cmd cert_get_property]].

[section "Certificate contexts"]

Operating on a certificate requires a [emph "certificate context"]
which encapsulates all information about the certificate.
Most often, the certificate of interest is an existing certificate
that is located in a certificate store. The commands for 
finding certificates in a store return a handle to a suitable
certificate context. Similarly, commands that create new certificates
or add certificates to a store return handles to certificate contexts
as well.

[para]
When no longer needed, certificate contexts must be freed by calling
[uri #cert_free [cmd cert_free]].

[section "Finding a certificate in a store"]
An existing certificate in a store can be retrieved in one of two ways:
[list_begin bullet]
[bullet] Enumerate each certificate in the store using
[uri #cert_store_enum_contents [cmd cert_store_enum_contents]] and
looking for a match using
[uri #cert_get_name [cmd cert_get_name]] or
[uri #cert_get_property [cmd cert_get_property]].
[bullet] Searching for a match on the subject name using
[uri #cert_store_find_certificate [cmd cert_store_find_certificate]].
[list_end]
Both these commands return a handle to a certificate context that
can be used for further operations on the certificate.

[section "Creating a new certificate"]
New certificates can be created
by commands such as 
[uri #cert_create_self_signed [cmd cert_create_self_signed]],
[uri #cert_create_signed_from_crypt_context [cmd cert_create_signed_from_crypt_context]] and
[uri #cert_create_certificate [cmd cert_create_certificate]].
These return handles to certificate contexts that are not associated with 
any store. The certificates must be explicitly placed in a certificate store
if desired.
[para]
Creating a new certificate involves several steps. As always, first
a cryptographic context is needed that defines the algorithms,
keys etc. that will be used to create the certificate.
[example {set crypt [crypt_context_acquire -csp {Microsoft Strong Cryptographic Provider} -keycontainer twapi_test_container -csptype prov_rsa_full -create 1]}]
This assumes a key container called twapi_test_container does not exist.
All the options specified above happen to be the defaults if unspecified.
[para]
The key container is created without any keys so we need to generate
public/private key pairs. As we will use the certificate for both
signing and key exchange, we generate two key pairs for the container.
[example_begin]
crypt_release_key [lb]crypt_context_generate_key $crypt signature -exportable 1[rb]
crypt_release_key [lb]crypt_context_generate_key $crypt keyexchange -exportable 1[rb]
[example_end]
Note we immediately release the key handles as they are not needed. This
does not destroy the underlying keys. Also, because we want to write
the certificate out to a file with the private keys, we mark the keys
exportable.
[para]
Next, we create a self signed certificate from the cryptographic context
we created. This will use the keys we just added.
[example {set cert [cert_create_self_signed_from_crypt_context "CN=TwapiTestCA" $crypt]}]

We now have a certificate context for a new self signed certificate.
In most cases, we will want to either store it in a certificate store
for future use or export it to a file. This is illustrated in 
succeeding sections of this document.
[para]
The cryptographic context is not needed any more and can be released.
[example {crypt_context_release $crypt}]

[section "Adding and deleting certificates from a store"]
Certificates can be added and deleted from certificate stores with
the commands
[uri #cert_store_add_certificate [cmd cert_store_add_certificate]]
and [uri #cert_store_delete_certificate [cmd cert_store_delete_certificate]]
respectively. Note that adding a certificate to a store creates a
[emph copy] of the certificate. The original certificate (context) is
unmodified.

[para]
The sample code below adds the certificate we created in the previous
section to a memory store. First we create the memory store.
[example {set store [cert_create_memory_store]}]
Then we add the certificate to it.
[example {set mcert [cert_store_add_certificate $store $cert]}]
This creates a copy of the certificate we created earlier. Since we
no longer need the original, we need to free it.
[example {cert_free $cert}]
There is now one crucial additional step. The association between
a certificate and its private key is maintained by the store and is not
part of the certificate. We therefore have to explicitly make the
association between the CSP key container and the new certificate context
for the memory store.

[example {cert_set_key_prov $mcert -csp {Microsoft Strong Cryptographic Provider} -keycontainer twapi_test_container -csptype prov_rsa_full -create 1}]
Notice we have specified exactly the key container we had created earlier.
[para]
The certificate is now stored in the memory store and will be available
as long as the volatile memory store is not closed. As a final step
we will export the certificate and the private keys to a file. This step
is only necessary if we want to move the certificate elsewhere.
[example_begin]
set fd [lb]open MyCert.pfx w[rb]
chan configure $fd -translation binary
puts -nonewline $fd [lb]cert_store_export $store -password [lb]password[rb] -exportprivate[rb]
close $fd
[example_end]
Note that because we are exporting private keys, it is important to
protect the exported certificate with a password.
[para]
Finally, assuming we have no use to hold on to the certificate, we can
free up the resources.
[example_begin]
cert_free $mcert
cert_store_close $store
[example_end]


TBD - using a cert for signing


[section Commands]

[list_begin definitions]

[call [cmd crypt_context_acquire] [opt [arg options]]]
Returns a handle to a cryptographic context based on the specified options.
[list_begin opt]
[opt_def [cmd -confidentiality] [arg BOOL]]
If specified as [const true], messages are to be encrypted.
[list_end]

[list_end]

[keywords authentication "message digest" encryption decryption SSPI ]

[manpage_end]
